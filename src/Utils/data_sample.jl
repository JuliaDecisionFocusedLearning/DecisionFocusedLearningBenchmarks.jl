"""
$TYPEDEF

Data sample data structure.
Its main purpose is to store datasets generated by the benchmarks.
It has 3 main fields: features `x`, cost parameters `θ` and solution `y`.
Additionally, it has an `info` field to store any additional information as a `NamedTuple`, usually the instance, but can be used for anything else.

# Fields
$TYPEDFIELDS
"""
struct DataSample{
    I<:NamedTuple,
    F<:Union{AbstractArray,Nothing},
    S<:Union{AbstractArray,Nothing},
    C<:Union{AbstractArray,Nothing},
}
    "input features (optional)"
    x::F
    "intermediate cost parameters (optional)"
    θ::C
    "output solution (optional)"
    y::S
    "additional information, usually the instance (optional)"
    info::I
end

"""
$TYPEDSIGNATURES

Constructor for `DataSample` with keyword arguments.

Additional keyword arguments beyond `x`, `θ`, and `y` are stored in the `info` field
and can be accessed directly (e.g., `data.instance` instead of `data.info.instance`).

# Examples
```julia
d = DataSample(x=[1,2,3], θ=[4,5,6], y=[7,8,9], instance="my_instance")
d.instance  # "my_instance"
```
"""
function DataSample(; x=nothing, θ=nothing, y=nothing, kwargs...)
    info = (; kwargs...)
    return DataSample(x, θ, y, info)
end

"""
$TYPEDSIGNATURES

Extended property access for `DataSample`.

Allows accessing `info` fields directly as properties (e.g., `d.instance` instead of `d.info.instance`).
"""
function Base.getproperty(d::DataSample, name::Symbol)
    if name in (:x, :θ, :y, :info)
        return getfield(d, name)
    else
        return getproperty(getfield(d, :info), name)
    end
end

"""
$TYPEDSIGNATURES

Return all property names of a `DataSample`, including both struct fields and `info` fields.

This enables tab completion for all available properties, including those stored in `info`.
"""
function Base.propertynames(d::DataSample, private::Bool=false)
    return (fieldnames(DataSample)..., propertynames(getfield(d, :info), private)...)
end

"""
$TYPEDSIGNATURES

Display a `DataSample` with truncated array representations for readability.

Large arrays are automatically truncated with ellipsis (`...`), similar to standard Julia array printing.
"""
function Base.show(io::IO, d::DataSample)
    fields = String[]
    io_limited = IOContext(io, :limit => true, :compact => true)
    if !isnothing(d.x)
        x_str = sprint(show, d.x; context=io_limited)
        push!(fields, "x=$x_str")
    end
    if !isnothing(d.θ)
        θ_str = sprint(show, d.θ; context=io_limited)
        push!(fields, "θ_true=$θ_str")
    end
    if !isnothing(d.y)
        y_str = sprint(show, d.y; context=io_limited)
        push!(fields, "y_true=$y_str")
    end
    for (key, value) in pairs(d.info)
        value_str = sprint(show, value; context=io_limited)
        push!(fields, "$key=$value_str")
    end
    return print(io, "DataSample(", join(fields, ", "), ")")
end

"""
$TYPEDSIGNATURES

Fit the given transform type (`ZScoreTransform` or `UnitRangeTransform`) on the dataset.
"""
function StatsBase.fit(transform_type, dataset::AbstractVector{<:DataSample}; kwargs...)
    x = hcat([d.x for d in dataset]...)
    return StatsBase.fit(transform_type, x; kwargs...)
end

"""
$TYPEDSIGNATURES

Transform the features in the dataset.
"""
function StatsBase.transform(t, dataset::AbstractVector{<:DataSample})
    return map(dataset) do d
        (; info, x, θ, y) = d
        DataSample(StatsBase.transform(t, x), θ, y, info)
    end
end

"""
$TYPEDSIGNATURES

Transform the features in the dataset, in place.
"""
function StatsBase.transform!(t, dataset::AbstractVector{<:DataSample})
    for d in dataset
        StatsBase.transform!(t, d.x)
    end
end

"""
$TYPEDSIGNATURES

Reconstruct the features in the dataset.
"""
function StatsBase.reconstruct(t, dataset::AbstractVector{<:DataSample})
    return map(dataset) do d
        (; info, x, θ, y) = d
        DataSample(StatsBase.reconstruct(t, x), θ, y, info)
    end
end

"""
$TYPEDSIGNATURES

Reconstruct the features in the dataset, in place.
"""
function StatsBase.reconstruct!(t, dataset::AbstractVector{<:DataSample})
    for d in dataset
        StatsBase.reconstruct!(t, d.x)
    end
end
