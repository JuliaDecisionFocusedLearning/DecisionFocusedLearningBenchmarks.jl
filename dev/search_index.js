var documenterSearchIndex = {"docs":
[{"location":"warcraft_tutorial/#Path-finding-on-image-maps","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"section"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In this tutorial, we showcase DecisionFocusedLearningBenchmarks.jl capabilities on one of its main benchmarks: the Warcraft benchmark. This benchmark problem is a simple path-finding problem where the goal is to find the shortest path between the top left and bottom right corners of a given image map. The map is represented as a 2D image representing a 12x12 grid, each cell having an unknown travel cost depending on the terrain type.","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"First, let's load the package and create a benchmark object as follows:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using DecisionFocusedLearningBenchmarks\nb = WarcraftBenchmark()","category":"page"},{"location":"warcraft_tutorial/#Dataset-generation","page":"Path-finding on image maps","title":"Dataset generation","text":"","category":"section"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"These benchmark objects behave as generators that can generate various needed elements in order to build an algorithm to tackle the problem. First of all, all benchmarks are capable of generating datasets as needed, using the generate_dataset method. This method takes as input the benchmark object for which the dataset is to be generated, and a second argument specifying the number of samples to generate:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"dataset = generate_dataset(b, 50);\nnothing #hide","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We obtain a vector of DataSample objects, containing all needed data for the problem. Subdatasets can be created through regular slicing:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"train_dataset, test_dataset = dataset[1:45], dataset[46:50]","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"And getting an individual sample will return a DataSample with four fields: x, info, θ, and y:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"sample = test_dataset[1]","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x correspond to the input features, i.e. the input image (3D array) in the Warcraft benchmark case:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x = sample.x","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ correspond to the true unknown terrain weights. We use the opposite of the true weights in order to formulate the optimization problem as a maximization problem:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ_true = sample.θ","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y correspond to the optimal shortest path, encoded as a binary matrix:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y_true = sample.y","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"info is not used in this benchmark, therefore set to nothing:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"isnothing(sample.info)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"For some benchmarks, we provide the following plotting method plot_data to visualize the data:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, sample)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can see here the terrain image, the true terrain weights, and the true shortest path avoiding the high cost cells.","category":"page"},{"location":"warcraft_tutorial/#Building-a-pipeline","page":"Path-finding on image maps","title":"Building a pipeline","text":"","category":"section"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"DecisionFocusedLearningBenchmarks also provides methods to build an hybrid machine learning and combinatorial optimization pipeline for the benchmark. First, the generate_statistical_model method generates a machine learning predictor to predict cell weights from the input image:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"model = generate_statistical_model(b)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case of the Warcraft benchmark, the model is a convolutional neural network built using the Flux.jl package.","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Note that the model is not trained yet, and its parameters are randomly initialized.","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Finally, the generate_maximizer method can be used to generate a combinatorial optimization algorithm that takes the predicted cell weights as input and returns the corresponding shortest path:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"maximizer = generate_maximizer(b; dijkstra=true)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case o fthe Warcraft benchmark, the method has an additional keyword argument to chose the algorithm to use: Dijkstra's algorithm or Bellman-Ford algorithm.","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y = maximizer(θ)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"As we can see, currently the pipeline predicts random noise as cell weights, and therefore the maximizer returns a straight line path.","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, DataSample(; x, θ, y))","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can evaluate the current pipeline performance using the optimality gap metric:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"starting_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft_tutorial/#Using-a-learning-algorithm","page":"Path-finding on image maps","title":"Using a learning algorithm","text":"","category":"section"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can now train the model using the InferOpt.jl package:","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using InferOpt\nusing Flux\nusing Plots\n\nperturbed_maximizer = PerturbedMultiplicative(maximizer; ε=0.2, nb_samples=100)\nloss = FenchelYoungLoss(perturbed_maximizer)\n\nstarting_gap = compute_gap(b, test_dataset, model, maximizer)\n\nopt_state = Flux.setup(Adam(1e-3), model)\nloss_history = Float64[]\nfor epoch in 1:50\n    val, grads = Flux.withgradient(model) do m\n        sum(loss(m(x), y) for (; x, y) in train_dataset) / length(train_dataset)\n    end\n    Flux.update!(opt_state, model, grads[1])\n    push!(loss_history, val)\nend\n\nplot(loss_history; xlabel=\"Epoch\", ylabel=\"Loss\", title=\"Training loss\")","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"final_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)\ny = maximizer(θ)\nplot_data(b, DataSample(; x, θ, y))","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"page"},{"location":"warcraft_tutorial/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/fixed_size_shortest_path/#Shortest-paths","page":"Shortest paths","title":"Shortest paths","text":"","category":"section"},{"location":"benchmarks/fixed_size_shortest_path/","page":"Shortest paths","title":"Shortest paths","text":"FixedSizeShortestPathBenchmark is a benchmark problem that consists of finding the shortest path in a grid graph between the top left and bottom right corners. In this benchmark, the grid size is the same for all instances.","category":"page"},{"location":"benchmarks/subset_selection/#Subset-Selection","page":"Subset Selection","title":"Subset Selection","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"SubsetSelectionBenchmark is the most trivial benchmark problem in this package. It is minimalistic and serves as a simple example for debugging and testing purposes.","category":"page"},{"location":"benchmarks/subset_selection/#Description","page":"Subset Selection","title":"Description","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"We have a set of n items, each item having an unknown value. We want to select a subset of k items that maximizes the sum of the values of the selected items.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"As input, instead of the items costs, we are given a feature vector, such that an unknown linear mapping between the feature vector and the value of the items exists.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"By default, this linear mapping is the identity mapping, i.e., the value of each item is equal to the value of the corresponding feature vector element. However, this mapping can be changed by setting the identity_mapping parameter to false.","category":"page"},{"location":"benchmarks/dvsp/#Dynamic-Vehicle-Scheduling","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The Dynamic Vehicle Scheduling Problem (DVSP) is a sequential decision-making problem where an agent must dynamically dispatch vehicles to serve customers that arrive over time.","category":"page"},{"location":"benchmarks/dvsp/#Problem-Description","page":"Dynamic Vehicle Scheduling","title":"Problem Description","text":"","category":"section"},{"location":"benchmarks/dvsp/#Overview","page":"Dynamic Vehicle Scheduling","title":"Overview","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"In the dynamic vehicle scheduling problem, a fleet operator must decide at each time step which customer requests to serve immediately and which to postpone to future time steps. The goal is to serve all customers by the end of the planning horizon while minimizing total travel time.","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"This is a simplified version of the more complex Dynamic Vehicle Routing Problem with Time Windows (DVRPTW), focusing on the core sequential decision-making aspects without capacity or time window constraints.","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The problem is characterized by:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Exogenous noise: customer arrivals are stochastic and follow a fixed known distribution, independent of the agent's actions\nCombinatorial action space: at each time step, the agent must build vehicle routes to serve selected customers, which leads to a huge combinatorial action space","category":"page"},{"location":"benchmarks/dvsp/#Mathematical-Formulation","page":"Dynamic Vehicle Scheduling","title":"Mathematical Formulation","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The dynamic vehicle scheduling problem can be formulated as a finite-horizon Markov Decision Process (MDP):","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"State Space mathcalS: At time step t, the state s_t consists of:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"s_t = (R_t D_t t)","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"where:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"R_t are the pending customer requests (not yet served), where each request r_i in R_t contains:\nx_i y_i: 2d spatial coordinates of the customer location\ntau_i: start time when the customer needs to be served\ns_i: service time required to serve the customer\nD_t indicates which requests must be dispatched this time step (i.e. that cannot be postponed further, otherwise they will be infeasible at the next time step because of their start time)\nt in 1 2 ldots T is the current time step","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The state also implicitly includes (constant over time):","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Travel duration matrix d_ij: time to travel from location i to location j\nDepot location","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Action Space mathcalA: The action at time step t is a set of vehicle routes:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"a_t = r_1 r_2 ldots r_k","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"where each route r_i is a sequence of customer that starts and ends at the depot.","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"A route is feasible if:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"It starts and ends at the depot\nIt follows time constraints, i.e. customers are served on time","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Transition Dynamics mathcalP(s_t+1  s_t a_t): After executing routes a_t:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Remove served customers from the pending request set\nGenerate new customer arrivals according to the underlying exogenous distribution\nUpdate must-dispatch set based on postponement rules","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Reward Function r(s_t a_t): The immediate reward is the negative total travel time of the routes:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"r(s_t a_t) = - sum_r in a_t sum_(ij) in r d_ij","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"where d_ij is the travel duration from location i to location j, and the sum is over all consecutive location pairs in each route r.","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Objective: Find a policy pi mathcalS to mathcalA that maximizes expected cumulative reward:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"max_pi mathbbEleftsum_t=1^T r(s_t pi(s_t)) right","category":"page"},{"location":"benchmarks/dvsp/#Key-Components","page":"Dynamic Vehicle Scheduling","title":"Key Components","text":"","category":"section"},{"location":"benchmarks/dvsp/#[DynamicVehicleSchedulingBenchmark](@ref)","page":"Dynamic Vehicle Scheduling","title":"DynamicVehicleSchedulingBenchmark","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The main benchmark configuration with the following parameters:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"max_requests_per_epoch: Maximum number of new customer requests per time step (default: 10)\nΔ_dispatch: Time delay between decision and vehicle dispatch (default: 1.0)\nepoch_duration: Duration of each decision time step (default: 1.0)\ntwo_dimensional_features: Whether to use simplified 2D features instead of full feature set (default: false)","category":"page"},{"location":"benchmarks/dvsp/#Instance-Generation","page":"Dynamic Vehicle Scheduling","title":"Instance Generation","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Problem instances are generated from static vehicle routing datasets and include:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Customer locations: Spatial coordinates for pickup/delivery points\nDepot location: Central starting and ending point for all routes\nTravel times: Distance/duration matrix between all location pairs\nService requirements: Time needed to serve each customer","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The dynamic version samples new customer arrivals from the static instance, drawing new customers by independently sampling their locations and service times.","category":"page"},{"location":"benchmarks/dvsp/#Features","page":"Dynamic Vehicle Scheduling","title":"Features","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The benchmark provides two feature representations:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Full Features (14-dimensional):","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Start times for postponable requests\nEnd times (start + service time)\nTravel time from depot to request\nTravel time from request to depot  \nSlack time until next time step\nQuantile-based travel times to other requests (9 quantiles)","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"2D Features (simplified):","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Travel time from depot to request\nMean travel time to other requests","category":"page"},{"location":"benchmarks/dvsp/#Benchmark-Policies","page":"Dynamic Vehicle Scheduling","title":"Benchmark Policies","text":"","category":"section"},{"location":"benchmarks/dvsp/#Lazy-Policy","page":"Dynamic Vehicle Scheduling","title":"Lazy Policy","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The lazy policy postpones all possible requests, serving only those that must be dispatched.","category":"page"},{"location":"benchmarks/dvsp/#Greedy-Policy","page":"Dynamic Vehicle Scheduling","title":"Greedy Policy","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The greedy policy serves all pending requests as soon as they arrive, without considering future consequences. ","category":"page"},{"location":"benchmarks/dvsp/#Decision-Focused-Learning-Policy","page":"Dynamic Vehicle Scheduling","title":"Decision-Focused Learning Policy","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"xrightarrowtextStates_t\nfboxNeural network varphi_w\nxrightarrowtextPrioritiestheta\nfboxPrize-collecting VSP\nxrightarrowtextRoutesa_t","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Components:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"Neural Network varphi_w: Takes current state features as input and predicts customer priorities theta = (theta_1 ldots theta_n)\nOptimization Layer: Solves the prize-collecting vehicle scheduling problem to determine optimal routes given the predicted priorities","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"The neural network architecture adapts to the feature dimensionality:","category":"page"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"2D features: Dense(2 => 1) followed by vectorization\nFull features: Dense(14 => 1) followed by vectorization","category":"page"},{"location":"benchmarks/portfolio_optimization/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"PortfolioOptimizationBenchmark is a Markovitz portfolio optimization problem, where asset prices are unknown, and only contextual data is available to predict these prices. The goal is to predict asset prices c and maximize the expected return of a portfolio, subject to a risk constraint using this maximization program:","category":"page"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\nmaxquad  c^top x\ntextstquad  x^top Sigma x leq gamma\n 1^top x leq 1\n x geq 0\nendaligned","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Interface","page":"API reference","title":"Interface","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","text":"abstract type AbstractBenchmark\n\nAbstract type interface for benchmark problems.\n\nThe following methods are mandatory for benchmarks:\n\ngenerate_dataset or generate_sample\ngenerate_statistical_model\ngenerate_maximizer\n\nThe following methods are optional:\n\nplot_data\nobjective_value\ncompute_gap\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.AbstractDynamicBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractDynamicBenchmark","text":"abstract type AbstractDynamicBenchmark{exogenous} <: AbstractStochasticBenchmark{exogenous}\n\nAbstract type interface for dynamic benchmark problems. This type should be used for benchmarks that involve multi-stage stochastic optimization problems.\n\nIt follows the same interface as AbstractStochasticBenchmark, with the addition of the following methods: TODO\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.AbstractEnvironment","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractEnvironment","text":"abstract type AbstractEnvironment\n\nAbstract type for environments in decision-focused learning benchmarks.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.AbstractStochasticBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractStochasticBenchmark","text":"abstract type AbstractStochasticBenchmark{exogenous} <: AbstractBenchmark\n\nAbstract type interface for stochastic benchmark problems. This type should be used for benchmarks that involve single stage stochastic optimization problems.\n\nIt follows the same interface as AbstractBenchmark, with the addition of the following methods:\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.DataSample","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.DataSample","text":"struct DataSample{I, F<:Union{Nothing, AbstractArray}, S<:Union{Nothing, AbstractArray}, C<:Union{Nothing, AbstractArray}}\n\nData sample data structure.\n\nFields\n\nx::Union{Nothing, AbstractArray}: input features (optional)\nθ::Union{Nothing, AbstractArray}: intermediate cost parameters (optional)\ny::Union{Nothing, AbstractArray}: output solution (optional)\ninfo::Any: additional information, usually the instance (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.Policy","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.Policy","text":"struct Policy{P}\n\nPolicy type for decision-focused learning benchmarks.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.Policy-Tuple","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.Policy","text":"Run the policy and get the next decision on the given environment/instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","text":"struct TopKMaximizer\n\nTop k maximizer.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer-Tuple{Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","text":"TopKMaximizer(\n    k\n) -> DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer\n\n\nReturn the top k indices of θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.average_tensor-Tuple{Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.average_tensor","text":"average_tensor(x)\n\nAverage the tensor x along its third axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.compute_gap","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer\n) -> Any\ncompute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer,\n    op\n) -> Any\n\n\nDefault behaviour of compute_gap for a benchmark problem where features, solutions and costs are all defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.compute_gap-2","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(::AbstractBenchmark, dataset::Vector{<:DataSample}, statistical_model, maximizer) -> Float64\n\nCompute the average relative optimality gap of the pipeline on the dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    envs::Vector{<:AbstractEnvironment};\n    ...\n) -> Tuple{Vector{Float64}, Any}\nevaluate_policy!(\n    policy,\n    envs::Vector{<:AbstractEnvironment},\n    episodes::Int64;\n    kwargs...\n) -> Tuple{Vector{Float64}, Any}\n\n\nRun the policy on the environments and return the total rewards and a dataset of observations. By default, the environments are reset before running the policy.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!-Tuple{Any, AbstractEnvironment, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    env::AbstractEnvironment,\n    episodes::Int64;\n    seed,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nEvaluate the policy on the environment and return the total reward and a dataset of observations. By default, the environment is reset before running the policy.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!-Tuple{Any, AbstractEnvironment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    env::AbstractEnvironment;\n    reset_env,\n    seed,\n    kwargs...\n) -> Tuple{Any, Vector{T} where T<:(DataSample{I, F, S, Nothing} where {I<:(NamedTuple{(:state, :reward), <:Tuple{Union{Nothing, DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}, Any}}), F<:Union{Nothing, AbstractArray}, S<:Union{Nothing, AbstractArray}})}\n\n\nRun the policy on the environment and return the total reward and a dataset of observations. By default, the environment is reset before running the policy.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_anticipative_solution","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_anticipative_solution","text":"generate_anticipative_solution(::AbstractStochasticBenchmark{true}, instance, scenario; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset-Tuple{AbstractBenchmark, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::AbstractBenchmark, dataset_size::Int; kwargs...) -> Vector{<:DataSample}\n\nGenerate a Vector of DataSample of length dataset_size for given benchmark. Content of the dataset can be visualized using plot_data, when it applies.\n\nBy default, it uses generate_sample to create each sample in the dataset, and passes any keyword arguments to it.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_environment","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environment","text":"generate_environment(::AbstractDynamicBenchmark, instance, rng::AbstractRNG; kwargs...)\n\nInitialize an environment for the given dynamic benchmark instance.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_environment-Tuple{AbstractDynamicBenchmark, DataSample, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environment","text":"generate_environment(\n    bench::AbstractDynamicBenchmark,\n    sample::DataSample,\n    rng::Random.AbstractRNG;\n    kwargs...\n) -> Union{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance{Float64}}, Random.MersenneTwister, Int64}, DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment{I, Random.MersenneTwister, Int64} where I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance}\n\n\nDefault behaviour of generate_environment applied to a data sample. Uses the info field of the sample as the instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_environments-Tuple{AbstractDynamicBenchmark, AbstractArray}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environments","text":"generate_environments(\n    bench::AbstractDynamicBenchmark,\n    dataset::AbstractArray;\n    seed,\n    rng,\n    kwargs...\n) -> Any\n\n\nGenerate a vector of environments for the given dynamic benchmark and dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(::AbstractBenchmark; kwargs...)\n\nGenerates a maximizer function. Returns a callable f: (θ; kwargs...) -> y, where θ is a cost array and y is a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_policies","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_policies","text":"generate_policies(::AbstractBenchmark) -> Vector{Policy}\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(::AbstractBenchmark, rng::AbstractRNG; kwargs...) -> DataSample\n\nGenerate a single DataSample for given benchmark. This is a low-level function that is used by generate_dataset to create a dataset of samples. It is not mandatory to implement this method, but it is recommended for benchmarks that have a well-defined way to generate individual samples. An alternative is to directly implement generate_dataset to create a dataset without generating individual samples.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_scenario","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_scenario","text":"generate_scenario(::AbstractStochasticBenchmark{true}, instance; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(::AbstractBenchmark; kwargs...)\n\nInitializes and return an untrained statistical model of the CO-ML pipeline. It's usually a Flux model, that takes a feature matrix x as input, and returns a cost array θ as output.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.get_path-Tuple{AbstractVector{<:Integer}, Integer, Integer}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.get_path","text":"get_path(\n    parents::AbstractVector{<:Integer},\n    s::Integer,\n    d::Integer\n) -> Vector{T} where T<:Integer\n\n\nRetrieve a path from the parents array and start sand endd`` of path.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.get_seed-Tuple{AbstractEnvironment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.get_seed","text":"get_seed(_::AbstractEnvironment) -> Union{Nothing, Int64}\n\n\nSeed accessor for environments. By default, environments have no seed. Override this method to provide a seed for the environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.grid_graph-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.grid_graph","text":"grid_graph(\n    costs::AbstractArray{R, 2};\n    acyclic\n) -> SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64}\n\n\nConvert a grid of cell costs into a weighted directed graph from SimpleWeightedGraphs.jl, where the vertices correspond to the cells and the edges are weighted by the cost of the arrival cell.\n\nIf acyclic = false, a cell has edges to each one of its 8 neighbors.\nIf acyclic = true, a cell has edges to its south, east and southeast neighbors only (ensures an acyclic graph where topological sort will work)\n\nThis can be used to model the Warcraft shortest paths problem of\n\nDifferentiation of Blackbox Combinatorial Solvers, Vlastelica et al. (2019)\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.highs_model-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.highs_model","text":"highs_model() -> JuMP.Model\n\n\nInitialize a HiGHS model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.is_terminated","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.is_terminated","text":"is_terminated(env::AbstractEnvironment) --> Bool\n\nCheck if the environment has reached a terminal state.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Tuple{AbstractBenchmark, DataSample}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample\n) -> NamedTuple{(:instance,), <:Tuple{Any}}\n\n\nFor benchmarks where there is an instance object, maximizer needs the instance object as a keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{AbstractBenchmark, DataSample{Nothing, F, S, C}}} where {F, S, C}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample{Nothing, F, S, C}\n) -> @NamedTuple{instance::Nothing}\n\n\nFor simple benchmarks where there is no instance object, maximizer does not need any keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.neg_tensor-Tuple{Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.neg_tensor","text":"neg_tensor(x)\n\nCompute minus softplus element-wise on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Tuple{AbstractBenchmark, AbstractArray, AbstractArray}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    _::AbstractBenchmark,\n    θ::AbstractArray,\n    y::AbstractArray\n) -> Any\n\n\nDefault behaviour of objective_value.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}, AbstractArray}} where {I, F, S, C<:AbstractArray}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S, C<:AbstractArray},\n    y::AbstractArray\n) -> Any\n\n\nCompute the objective value of given solution y.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}}} where {I, F, S<:AbstractArray, C}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S<:AbstractArray, C}\n) -> Any\n\n\nCompute the objective value of the target in the sample (needs to exist).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.observe","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.observe","text":"observe(env::AbstractEnvironment) --> Tuple\n\nGet the current observation from the environment. This function should return a tuple of two elements:     1. An array of features representing the current state of the environment.     2. An internal state of the environment, which can be used for further processing (return nothing if not needed).\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.path_to_matrix-Tuple{Vector{<:Integer}, Integer, Integer}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.path_to_matrix","text":"path_to_matrix(\n    path::Vector{<:Integer},\n    h::Integer,\n    w::Integer\n) -> Matrix{Int64}\n\n\nTransform path into a binary matrix of size (h, w) where each cell is 1 if the cell is part of the path, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.plot_data","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(::AbstractBenchmark, ::DataSample; kwargs...)\n\nPlot a data sample from the dataset created by generate_dataset. Check the specific benchmark documentation of plot_data for more details on the arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.reset!","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.reset!","text":"reset!(env::AbstractEnvironment; reset_rng::Bool, seed=get_seed(env)) --> Nothing\n\nReset the environment to its initial state. If reset_rng is true, the random number generator is reset to the given seed.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.scip_model-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.scip_model","text":"scip_model() -> JuMP.Model\n\n\nInitialize a SCIP model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims-Tuple{Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims","text":"squeeze_last_dims(x)\n\nSqueeze two last dimensions on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.step!","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.step!","text":"step!(env::AbstractEnvironment, action) --> Float64\n\nPerform a step in the environment with the given action. Returns the reward received after taking the action. This function may also update the internal state of the environment. If the environment is terminated, it should raise an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.coord_to_index-NTuple{4, Integer}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.coord_to_index","text":"coord_to_index(\n    i::Integer,\n    j::Integer,\n    h::Integer,\n    w::Integer\n) -> Any\n\n\nGiven a pair of row-column coordinates (i, j) on a grid of size (h, w), compute the corresponding vertex index in the graph generated by grid_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.count_edges-Tuple{Integer, Integer}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.count_edges","text":"count_edges(h::Integer, w::Integer; acyclic)\n\n\nCompute the number of edges in a grid graph of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.index_to_coord-Tuple{Integer, Integer, Integer}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.index_to_coord","text":"index_to_coord(\n    v::Integer,\n    h::Integer,\n    w::Integer\n) -> Tuple{Any, Any}\n\n\nGiven a vertex index in the graph generated by grid_graph, compute the corresponding row-column coordinates (i, j) on a grid of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem-Tuple{AbstractBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem","text":"is_minimization_problem(_::AbstractBenchmark) -> Bool\n\n\nCheck if the benchmark is a minimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.plot_instance","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.plot_instance","text":"plot_instance(::AbstractBenchmark, instance; kwargs...)\n\nPlot the instance object of the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.plot_solution","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.plot_solution","text":"plot_solution(::AbstractBenchmark, sample::DataSample, [solution]; kwargs...)\n\nPlot solution if given, else plot the target solution in the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.fit-Tuple{Any, AbstractVector{<:DataSample}}","page":"API reference","title":"StatsAPI.fit","text":"fit(\n    transform_type,\n    dataset::AbstractVector{<:DataSample};\n    kwargs...\n)\n\n\nFit the given transform type (ZScoreTransform or UnitRangeTransform) on the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.reconstruct!-Tuple{Any, AbstractVector{<:DataSample}}","page":"API reference","title":"StatsBase.reconstruct!","text":"reconstruct!(t, dataset::AbstractVector{<:DataSample})\n\n\nReconstruct the features in the dataset, in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.reconstruct-Tuple{Any, AbstractVector{<:DataSample}}","page":"API reference","title":"StatsBase.reconstruct","text":"reconstruct(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nReconstruct the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.transform!-Tuple{Any, AbstractVector{<:DataSample}}","page":"API reference","title":"StatsBase.transform!","text":"transform!(t, dataset::AbstractVector{<:DataSample})\n\n\nTransform the features in the dataset, in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.transform-Tuple{Any, AbstractVector{<:DataSample}}","page":"API reference","title":"StatsBase.transform","text":"transform(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nTransform the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#Argmax2D","page":"API reference","title":"Argmax2D","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"struct Argmax2DBenchmark{E, R} <: AbstractBenchmark\n\nArgmax becnhmark on a 2d polytope.\n\nFields\n\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\npolytope_vertex_range::Any: \n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"Argmax2DBenchmark(\n;\n    nb_features,\n    seed,\n    polytope_vertex_range\n) -> Argmax2DBenchmark{E, Vector{Int64}} where E<:(Flux.Dense{typeof(identity), Matrix{Float32}})\n\n\nCustom constructor for Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{Argmax2DBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    _::Argmax2DBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax2D.maximizer)\n\n\nMaximizer for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{Argmax2DBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::Argmax2DBenchmark,\n    rng::Random.AbstractRNG\n) -> DataSample{_A, Vector{Float32}} where _A\n\n\nGenerate a sample for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{Argmax2DBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::Argmax2DBenchmark;\n    seed,\n    rng\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nGenerate a statistical model for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{Argmax2DBenchmark, DataSample}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    bench::Argmax2DBenchmark,\n    sample::DataSample;\n    info,\n    θ,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the data sample for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#Argmax","page":"API reference","title":"Argmax","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"struct ArgmaxBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with an argmax as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"ArgmaxBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> ArgmaxBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for ArgmaxBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax","text":"one_hot_argmax(\n    z::AbstractArray{R<:Real, 1};\n    kwargs...\n) -> Any\n\n\nOne-hot encoding of the argmax function.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{ArgmaxBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::ArgmaxBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax)\n\n\nReturn an argmax maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{ArgmaxBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::ArgmaxBenchmark,\n    rng::Random.AbstractRNG;\n    noise_std\n) -> DataSample{Nothing, Matrix{Float32}}\n\n\nGenerate a data sample for the argmax benchmark. This function generates a random feature matrix, computes the costs using the encoder, and adds noise to the costs before computing a target solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{ArgmaxBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::ArgmaxBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Dynamic-Vehicle-Scheduling","page":"API reference","title":"Dynamic Vehicle Scheduling","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DynamicVehicleSchedulingBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DynamicVehicleSchedulingBenchmark","text":"struct DynamicVehicleSchedulingBenchmark <: AbstractDynamicBenchmark{true}\n\nAbstract type for dynamic vehicle scheduling benchmarks.\n\nFields\n\nmax_requests_per_epoch::Int64: maximum number of customers entering the system per epoch\nΔ_dispatch::Float64: time between decision and dispatch of a vehicle\nepoch_duration::Float64: duration of an epoch\ntwo_dimensional_features::Bool: whether to use two-dimensional features\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv","text":"DVSPEnv(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance;\n    seed\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance{Float64}}, Random.MersenneTwister, Nothing}\n\n\nConstructor for DVSPEnv.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState","text":"State data structure for the Dynamic Vehicle Scheduling Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance","text":"struct Instance{I<:DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance, T}\n\nInstance data structure for the dynamic vehicle scheduling problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.KleopatraVSPPolicy","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.KleopatraVSPPolicy","text":"struct KleopatraVSPPolicy{P}\n\nKleopatra policy for the Dynamic Vehicle Scheduling Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point","text":"struct Point{T}\n\nBasic point structure.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance","text":"struct StaticInstance{T}\n\nInstance data structure for the (deterministic and static) Vehicle Scheduling Problem.\n\nFields\n\ncoordinate::Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T: coordinates of the locations. The first one is always the depot.\nservice_time::Vector: service time at each location\nstart_time::Vector: start time at each location\nduration::Matrix: duration matrix between locations\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","text":"struct VSPSolution\n\nSolution for the static Vehicle Scheduling Problem.\n\nFields\n\nroutes::Vector{Vector{Int64}}: list of routes, each route being a list of request indices in corresponding instance (excluding the depot).\nedge_matrix::BitMatrix: size (nblocations, nblocations). edge_matrix[i, j] is equal to 1 if a route takes edge (i, j).\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution-Tuple{Vector{Vector{Int64}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","text":"VSPSolution(\n    routes::Vector{Vector{Int64}};\n    max_index\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n\n\nBuild a VSPSolution from routes. Set max_index to manually define the size of the edge_index matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.animate_epochs-Tuple{Vector{<:DataSample}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.animate_epochs","text":"animate_epochs(\n    data_samples::Vector{<:DataSample};\n    filename,\n    fps,\n    figsize,\n    margin,\n    legend_margin_factor,\n    titlefontsize,\n    guidefontsize,\n    legendfontsize,\n    tickfontsize,\n    show_axis_labels,\n    show_cost_bar,\n    show_colorbar,\n    cost_bar_width,\n    cost_bar_margin,\n    cost_bar_color_palette,\n    kwargs...\n) -> Plots.Animation\n\n\nCreate an animated GIF showing the evolution of states and routes over epochs. Each frame shows the state and routes for one epoch.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.anticipative_solver","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.anticipative_solver","text":"anticipative_solver(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv;\n    ...\n) -> Tuple{Union{Float64, Vector{Float64}}, Vector}\nanticipative_solver(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    scenario;\n    model_builder,\n    two_dimensional_features,\n    reset_env,\n    nb_epochs,\n    seed,\n    verbose\n) -> Tuple{Union{Float64, Vector{Float64}}, Vector}\n\n\nSolve the anticipative VSP problem for environment env. For this, it uses the current environment history, so make sure that the environment is terminated before calling this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.apply_routes!-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, Vector{Vector{Int64}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.apply_routes!","text":"remove dispatched customers, and update must-dispatch and postponable flags.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.build_plot_data-Tuple{Vector{<:DataSample}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.build_plot_data","text":"Return a Dict with plot-ready information extracted from a vector of DataSample objects.\n\nThe returned dictionary contains:\n\n:n_epochs => Int\n:coordinates => Vector{Vector{Tuple{Float64,Float64}}} (per-epoch list of (x,y) tuples, empty if instance missing)\n:start_times => Vector{Vector{Float64}} (per-epoch start times, empty if instance missing)\n:node_types => Vector{Vector{Symbol}} (per-epoch node-type labels aligned with coordinates)\n:routes => Vector{Vector{Vector{Int}}} (per-epoch normalized routes; empty vector when no routes)\n:epoch_costs => Vector{Float64} (per-epoch cost; NaN if not computable)\n\nThis lets plotting code build figures without depending on plotting internals.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate","text":"coordinate(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T\n\n\nGet the coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate","text":"coordinate(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T\n\n\nGet the coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.cost-Tuple{Vector{Vector{Int64}}, AbstractMatrix}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.cost","text":"cost(\n    routes::Vector{Vector{Int64}},\n    duration::AbstractMatrix\n) -> Any\n\n\nCompute the total cost of a set of routes given a distance matrix, i.e. the sum of the distances between each location in the route. Note that the first location is implicitly assumed to be the depot, and should not appear in the route.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph","text":"create_graph(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nCreate the acyclic digraph associated with the given VSP state.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph","text":"create_graph(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nCreate the acyclic digraph associated with the given VSP instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count","text":"customer_count(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Int64\n\n\nReturn the number of customers in state.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count","text":"customer_count(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Int64\n\n\nReturn the number of customers in instance (excluding the depot).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration","text":"duration(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Matrix\n\n\nGet the duration matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration","text":"duration(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Matrix\n\n\nGet the duration matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.edge_matrix-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.edge_matrix","text":"edge_matrix(\n    solution::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n) -> BitMatrix\n\n\nGet edge matrix from solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.is_feasible-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, Vector{Vector{Int64}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.is_feasible","text":"is_feasible(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState,\n    routes::Vector{Vector{Int64}};\n    verbose\n) -> Bool\n\n\nCheck if the given routes are feasible. Routes should be given with global indexation. Use env_routes_from_state_routes if needed to convert the indices beforehand.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count","text":"location_count(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Int64\n\n\nReturn the number of locations in state (customers + depot).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count","text":"location_count(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Int64\n\n\nReturn the number of locations in instance (customers + depot).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.planning_start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.planning_start_time","text":"planning_start_time(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Any\n\n\nGet the planning start time of the environment, i.e. the time at which vehicles routes dispatched in current epoch can depart.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_epochs-Tuple{Vector{<:DataSample}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_epochs","text":"plot_epochs(\n    data_samples::Vector{<:DataSample};\n    plot_routes_flag,\n    cols,\n    figsize,\n    margin,\n    legend_margin_factor,\n    titlefontsize,\n    guidefontsize,\n    legendfontsize,\n    tickfontsize,\n    show_axis_labels,\n    show_colorbar,\n    kwargs...\n) -> Any\n\n\nPlot multiple epochs side by side from a vector of DataSample objects. Each DataSample should contain an instance (DVSPState) and optionally y_true (routes). All subplots will use the same xlims and ylims to show the dynamics clearly.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_instance-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_instance","text":"plot_instance(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the given static VSP instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_routes-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, BitMatrix}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_routes","text":"plot_routes(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState,\n    routes::BitMatrix;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a given DVSPState with routes overlaid. This version accepts routes as a BitMatrix where entry (i,j) = true indicates an edge from location i to location j.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_routes-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, Vector{Vector{Int64}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_routes","text":"plot_routes(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState,\n    routes::Vector{Vector{Int64}};\n    reward,\n    route_color,\n    route_linewidth,\n    route_alpha,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a given DVSPState with routes overlaid, showing depot, customers, and vehicle routes. Routes should be provided as a vector of vectors, where each inner vector contains the indices of locations visited by that route (excluding the depot).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_state-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_state","text":"plot_state(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState;\n    customer_markersize,\n    depot_markersize,\n    alpha_depot,\n    depot_color,\n    depot_marker,\n    must_dispatch_color,\n    postponable_color,\n    must_dispatch_marker,\n    postponable_marker,\n    show_axis_labels,\n    markerstrokewidth,\n    show_colorbar,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a given DVSPState showing depot, must-dispatch customers, and postponable customers.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.prize_collecting_vsp-Tuple{AbstractVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.prize_collecting_vsp","text":"prize_collecting_vsp(\n    θ::AbstractVector;\n    instance,\n    model_builder,\n    kwargs...\n)\n\n\nSolve the Prize Collecting Vehicle Scheduling Problem defined by instance and prize vector θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.read_vsp_instance-Tuple{String}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.read_vsp_instance","text":"read_vsp_instance(\n    filepath::String;\n    rounded,\n    normalization\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n\n\nCreate a VSPInstance from file filepath containing a VRPTW instance. It uses time window values to compute task times as the middle of the interval.\n\nRound all values to Int if rounded=true. Normalize all time values by the normalization parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes","text":"retrieve_routes(\n    y::AbstractArray,\n    graph::Graphs.AbstractGraph\n) -> Vector{Vector{Int64}}\n\n\nRetrieve routes solution from the given MIP solution y matrix and graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes_anticipative-Tuple{AbstractArray, DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv, Any, Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes_anticipative","text":"retrieve_routes_anticipative(\n    y::AbstractArray,\n    dvspenv::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    customer_index,\n    epoch_indices\n) -> Any\n\n\nRetrieve anticipative routes solution from the given MIP solution y. Outputs a set of routes per epoch.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.routes-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.routes","text":"routes(\n    solution::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n) -> Vector{Vector{Int64}}\n\n\nGet routes from solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.sample_indices-Tuple{Random.AbstractRNG, Any, Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.sample_indices","text":"sample_indices(rng::Random.AbstractRNG, k, N) -> Any\n\n\nSample k random different indices from 2 to N+1.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time","text":"service_time(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Vector\n\n\nGet the service time vector\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time","text":"service_time(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Vector\n\n\nGet the service time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time","text":"start_time(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Vector\n\n\nGet the start time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time","text":"start_time(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Vector\n\n\nGet the start time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.time","text":"time(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Any\n\n\nGet the current time of the environment, i.e. the start time of the current_epoch.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.is_terminated-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.is_terminated","text":"is_terminated(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Bool\n\n\nCheck if the episode is terminated, i.e. if the current epoch is the last one.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.observe-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.observe","text":"observe(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Tuple{Any, DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}\n\n\nGet the current state of the environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.reset!-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.reset!","text":"reset!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv;\n    seed,\n    reset_rng\n)\n\n\nReset the environment to its initial state. Also reset the rng to seed if reset_rng is set to true.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.step!-2","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.step!","text":"step!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    routes\n) -> Any\nstep!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    routes,\n    scenario\n) -> Any\n\n\nRemove dispatched customers, advance time, and add new requests to the environment.\n\n\n\n\n\n","category":"function"},{"location":"api/#Dynamic-Assortment","page":"API reference","title":"Dynamic Assortment","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.DynamicAssortmentBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.DynamicAssortmentBenchmark","text":"struct DynamicAssortmentBenchmark{exogenous, M} <: AbstractDynamicBenchmark{exogenous}\n\nBenchmark for the dynamic assortment problem.\n\nFields\n\ncustomer_choice_model::Any: customer choice model (price, hype, saturation, and features)\nN::Int64: number of items\nd::Int64: dimension of feature vectors (in addition to hype, satisfaction, and price)\nK::Int64: assortment size constraint\nmax_steps::Int64: number of steps per episode\n\nReference: https://arxiv.org/abs/2505.19053\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment","text":"mutable struct Environment{I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance, R<:Random.AbstractRNG, S<:Union{Nothing, Int64}} <: AbstractEnvironment\n\nEnvironment for the dynamic assortment problem.\n\nFields\n\ninstance::DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance: associated instance\nstep::Int64: current step\npurchase_history::Vector{Int64}: purchase history (used to update hype feature)\nrng::Random.AbstractRNG: rng\nseed::Union{Nothing, Int64}: seed for RNG\nutility::Vector{Float64}: customer utility for each item\nfeatures::Matrix{Float64}: current full features\nd_features::Matrix{Float64}: satisfaction + hype feature change from the last step\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment","text":"Environment(\n    instance::DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance;\n    seed,\n    rng\n) -> DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment{I, Random.MersenneTwister, Int64} where I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance\n\n\nCreates an Environment from an Instance of the dynamic assortment benchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance","text":"struct Instance{B<:DynamicAssortmentBenchmark}\n\nInstance of the dynamic assortment problem.\n\nFields\n\nconfig::DynamicAssortmentBenchmark: associated benchmark\nprices::Vector{Float64}: item prices (including no purchase action)\nfeatures::Matrix{Float64}: static features, size (d, N)\nstarting_hype_and_saturation::Matrix{Float64}: starting hype and saturation features, size (2, N)\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance-Tuple{DynamicAssortmentBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance","text":"Instance(\n    b::DynamicAssortmentBenchmark,\n    rng::Random.AbstractRNG\n) -> DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance\n\n\nGenerates a random instance:\n\nrandom prices uniformly in [1, 10]\nrandom features uniformly in [1, 10]\nrandom starting hype and saturation uniformly in [1, 10]\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.buy_item!-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.buy_item!","text":"buy_item!(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment,\n    item::Int64\n)\n\n\nUpdates the environment state after a purchase of item.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.choice_probabilities-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment, BitVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.choice_probabilities","text":"choice_probabilities(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment,\n    assortment::BitVector\n) -> Vector{Float64}\n\n\nCompute the choice probabilities for each item in assortment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.compute_expected_revenue-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment, BitVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.compute_expected_revenue","text":"compute_expected_revenue(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment,\n    assortment::BitVector\n) -> Float64\n\n\nCompute the expected revenue of offering assortment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.expert_policy-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.expert_policy","text":"expert_policy(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> BitVector\n\n\nExpert policy that computes the optimal assortment by enumerating all possible assortments.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.greedy_policy-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.greedy_policy","text":"greedy_policy(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> BitVector\n\n\nGreedy policy that selects the assortment containing items with the highest prices.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.DynamicAssortment.hype_update-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.hype_update","text":"hype_update(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> Vector{Float64}\n\n\nCompute an hype multiplier vector based on the purchase history. The hype multiplier (equal to 1 by default) for each item is updated as follows:\n\nIf the item was purchased in the last step, its hype multiplier increases by 0.02.\nIf the item was purchased in the last 2 to 5 steps, its hype multiplier decreases by 0.005.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_environment-Tuple{DynamicAssortmentBenchmark, DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environment","text":"generate_environment(\n    ::DynamicAssortmentBenchmark,\n    instance::DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance,\n    rng::Random.AbstractRNG;\n    kwargs...\n) -> DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment{I, Random.MersenneTwister, Int64} where I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance\n\n\nCreates an Environment from an Instance of the dynamic assortment benchmark. The seed of the environment is randomly generated using the provided random number generator.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{DynamicAssortmentBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    b::DynamicAssortmentBenchmark\n) -> DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer\n\n\nOutputs a top k maximizer, with k being the assortment size of the benchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_policies-Tuple{DynamicAssortmentBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_policies","text":"generate_policies(\n    _::DynamicAssortmentBenchmark\n) -> Tuple{Policy{typeof(DecisionFocusedLearningBenchmarks.DynamicAssortment.expert_policy)}, Policy{typeof(DecisionFocusedLearningBenchmarks.DynamicAssortment.greedy_policy)}}\n\n\nReturns two policies for the dynamic assortment benchmark:\n\nGreedy: selects the assortment containing items with the highest prices\nExpert: selects the assortment with the highest expected revenue (through brute-force enumeration)\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-2","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    b::DynamicAssortmentBenchmark\n) -> DataSample{I, Nothing, Nothing, Nothing} where I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance\ngenerate_sample(\n    b::DynamicAssortmentBenchmark,\n    rng::Random.AbstractRNG\n) -> DataSample{I, Nothing, Nothing, Nothing} where I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance\n\n\nOutputs a data sample containing an Instance.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{DynamicAssortmentBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    b::DynamicAssortmentBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nGenerates a statistical model for the dynamic assortment benchmark. The model is a small neural network with one hidden layer of size 5 and no activation function.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.get_seed-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.get_seed","text":"get_seed(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> Union{Nothing, Int64}\n\n\nOutputs the seed of the environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.is_terminated-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.is_terminated","text":"is_terminated(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> Bool\n\n\nChecks if the environment has reached the maximum number of steps.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.observe-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.observe","text":"observe(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment\n) -> Tuple{Matrix{Float64}, Nothing}\n\n\nFeatures observed by the agent at current step, as a concatenation of:\n\ncurrent full features (including prices, hype, saturation, and static features)\nchange in hype and saturation features from the last step\nchange in hype and saturation features from the starting state\nnormalized current step (divided by max steps and multiplied by 10)\n\nAll features are normalized by dividing by 10.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.reset!-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.reset!","text":"reset!(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment;\n    reset_rng,\n    seed\n)\n\n\nResets the environment to the initial state:\n\nreset the rng if reset_rng is true\nreset the step to 1\nreset the features to the initial features\nreset the change in features to zero\nreset the utility to the initial utility\nclear the purchase history\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.step!-Tuple{DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment, BitVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.step!","text":"step!(\n    env::DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment,\n    assortment::BitVector\n) -> Float64\n\n\nPerforms one step in the environment given an assortment. Draw an item according to the customer choice model and updates the environment state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Fixed-size-shortest-path","page":"API reference","title":"Fixed-size shortest path","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"struct FixedSizeShortestPathBenchmark <: AbstractBenchmark\n\nBenchmark problem for the shortest path problem. In this benchmark, all graphs are acyclic directed grids, all of the same size grid_size. Features are given at instance level (one dimensional vector of length p for each graph).\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int64}: grid graph instance\ngrid_size::Tuple{Int64, Int64}: grid size of graphs\np::Int64: size of feature vectors\ndeg::Int64: degree of formula between features and true weights\nν::Float32: multiplicative noise for true weights sampled between [1-ν, 1+ν], should be between 0 and 1\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"FixedSizeShortestPathBenchmark(\n;\n    grid_size,\n    p,\n    deg,\n    ν\n) -> FixedSizeShortestPathBenchmark\n\n\nConstructor for FixedSizeShortestPathBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{FixedSizeShortestPathBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::FixedSizeShortestPathBenchmark;\n    use_dijkstra\n) -> DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#8\"{DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#5#9\"{typeof(Graphs.dijkstra_shortest_paths), Vector{Int64}, Vector{Int64}, Int64, Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}}\n\n\nOutputs a function that computes the longest path on the grid graph, given edge weights θ as input.\n\nmaximizer = generate_maximizer(bench)\nmaximizer(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{FixedSizeShortestPathBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::FixedSizeShortestPathBenchmark\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{FixedSizeShortestPathBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::FixedSizeShortestPathBenchmark,\n    rng::Random.AbstractRNG;\n    type\n) -> Union{DataSample{Nothing, Vector{Float32}, BitVector, Vector{Float32}}, DataSample{Nothing, Vector{Float32}, BitVector, Vector{Float64}}}\n\n\nGenerate a labeled sample for the fixed size shortest path benchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#Portfolio-Optimization","page":"API reference","title":"Portfolio Optimization","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"struct PortfolioOptimizationBenchmark <: AbstractBenchmark\n\nBenchmark problem for the portfolio optimization problem.\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\nd::Int64: number of assets\np::Int64: size of feature vectors\ndeg::Int64: hypermarameter for data generation\nν::Float32: another hyperparameter, should be positive\nΣ::Matrix{Float32}: covariance matrix\nγ::Float32: maximum variance of portfolio\nL::Matrix{Float32}: useful for dataset generation\nf::Vector{Float32}: useful for dataset generation\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"PortfolioOptimizationBenchmark(\n;\n    d,\n    p,\n    deg,\n    ν,\n    seed\n) -> PortfolioOptimizationBenchmark\n\n\nConstructor for PortfolioOptimizationBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{PortfolioOptimizationBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::PortfolioOptimizationBenchmark\n) -> DecisionFocusedLearningBenchmarks.PortfolioOptimization.var\"#portfolio_maximizer#3\"{Float32, Matrix{Float32}, Int64}\n\n\nCreate a function solving the MIQP formulation of the portfolio optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{PortfolioOptimizationBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::PortfolioOptimizationBenchmark\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{PortfolioOptimizationBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::PortfolioOptimizationBenchmark,\n    rng::Random.AbstractRNG;\n    type\n) -> DataSample{Nothing, Vector{Float32}, Vector{Float64}, Vector{Float64}}\n\n\nGenerate a labeled sample for the portfolio optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ranking","page":"API reference","title":"Ranking","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"struct RankingBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with ranking as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"RankingBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> RankingBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for RankingBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Ranking.ranking-Tuple{AbstractVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Ranking.ranking","text":"ranking(θ::AbstractVector; rev, kwargs...) -> Any\n\n\nCompute the vector r such that rᵢ is the rank of θᵢ in θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{RankingBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::RankingBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Ranking.ranking)\n\n\nReturn a ranking maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{RankingBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::RankingBenchmark,\n    rng::Random.AbstractRNG;\n    noise_std\n) -> DataSample{Nothing, Matrix{Float32}}\n\n\nGenerate a labeled sample for the ranking problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{RankingBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::RankingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#Subset-selection","page":"API reference","title":"Subset selection","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","text":"struct SubsetSelectionBenchmark{M} <: AbstractBenchmark\n\nBenchmark problem for the subset selection problem. Reference: https://arxiv.org/abs/2307.13565.\n\nThe goal is to select the best k items from a set of n items, without knowing their values, but only observing some features.\n\nFields\n\nn::Int64: total number of items\nk::Int64: number of items to select\nmapping::Any: hidden unknown mapping from features to costs\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{SubsetSelectionBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::SubsetSelectionBenchmark\n) -> Base.Fix2{typeof(DecisionFocusedLearningBenchmarks.SubsetSelection.top_k), Int64}\n\n\nReturn a top k maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{SubsetSelectionBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::SubsetSelectionBenchmark;\n    seed\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{SubsetSelectionBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::SubsetSelectionBenchmark,\n    rng::Random.AbstractRNG\n) -> DataSample{Nothing, Vector{Float32}}\n\n\nGenerate a labeled instance for the subset selection problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Stochastic-Vehicle-Scheduling","page":"API reference","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","text":"struct StochasticVehicleSchedulingBenchmark <: AbstractBenchmark\n\nData structure for a stochastic vehicle scheduling benchmark.\n\nFields\n\nnb_tasks::Int64: number of tasks in each instance\nnb_scenarios::Int64: number of scenarios in each instance\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm","text":"column_generation_algorithm(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    bounding,\n    use_convex_resources,\n    silent,\n    close_gap\n) -> BitVector\n\n\nSolve input instance using column generation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip","text":"compact_linearized_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact MIP. Quadratic constraints are linearized using Mc Cormick linearization. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip","text":"compact_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact quadratic MIP. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\nwarning: Warning\nYou need to use a solver that supports quadratic constraints to use this method.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip","text":"deterministic_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    model_builder,\n    silent\n) -> Any\n\n\nSolves the deterministic version of the vehicle scheduling problem using a MIP model. Does not take into account the stochastic nature of the problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible","text":"is_feasible(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    verbose\n) -> Bool\n\n\nCheck if solution is an admissible solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search","text":"local_search(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    num_iterations\n) -> BitVector\n\n\nVery simple heuristic, using local_search     initialised with the solution of the deterministic Linear program\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance","text":"plot_instance(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution","text":"plot_solution(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{StochasticVehicleSchedulingBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    ::StochasticVehicleSchedulingBenchmark;\n    model_builder\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer{typeof(DecisionFocusedLearningBenchmarks.Utils.highs_model)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{StochasticVehicleSchedulingBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::StochasticVehicleSchedulingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"struct City\n\nData structure for a city in the vehicle scheduling problem. Contains all the relevant information to build an instance of the problem.\n\nFields\n\nwidth::Int64: city width (in minutes)\nvehicle_cost::Float64: cost of a vehicle in the objective function\ndelay_cost::Float64: cost of one minute delay in the objective function\nnb_tasks::Int64: number of tasks to fulfill\ntasks::Vector{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}: tasks list (see Task), that should be ordered by start time\ndistrict_width::Int64: idth (in minutes) of each district\ndistricts::Matrix{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District}: districts matrix (see District), indices corresponding to their relative positions\nrandom_inter_area_factor::Distributions.LogNormal{Float64}: a log-normal distribution modeling delay between districts\nscenario_inter_area_factor::Matrix{Float64}: size (nb_scenarios, 24), each row correspond to one scenario, each column to one hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"City(\n;\n    nb_scenarios,\n    width,\n    vehicle_cost,\n    nb_tasks,\n    tasks,\n    district_width,\n    districts,\n    delay_cost,\n    random_inter_area_factor,\n    scenario_inter_area_factor\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nConstructor for City.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"struct District\n\nData structure for a district in the vehicle scheduling problem.\n\nFields\n\nrandom_delay::Distributions.LogNormal{Float64}: log-normal distribution modeling the district delay\nscenario_delay::Matrix{Float64}: size (nb_scenarios, 24), observed delays for each scenario and hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"District(; random_delay, nb_scenarios)\n\n\nConstructor for District. Initialize a district with a given number of scenarios, with zeros in scenario_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"struct Instance{CC, G<:Graphs.AbstractGraph, M1<:(AbstractMatrix), M2<:(AbstractMatrix), F, C}\n\nInstance of the stochastic VSP problem.\n\nFields\n\ngraph::Graphs.AbstractGraph: graph computed from city with the create_VSP_graph(city::City) method\nfeatures::Matrix: features matrix computed from city\nslacks::AbstractMatrix: slack matrix\nintrinsic_delays::AbstractMatrix: intrinsic delays scenario matrix\nvehicle_cost::Any: cost of a vehicle\ndelay_cost::Any: cost of one minute delay\ncity::Any: associated city\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"Instance(\n;\n    nb_tasks,\n    nb_scenarios,\n    rng,\n    store_city,\n    kwargs...\n)\n\n\nConstructor for Instance. Build an Instance for the stochatsic vehicle scheduling problem, with nb_tasks tasks and nb_scenarios scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","text":"struct Point\n\n2D point data structure.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"struct Solution\n\nShould always be associated with an Instance.\n\nFields\n\nvalue::BitVector: for each graph edge of instance, 1 if selected, else 0\npath_value::BitMatrix: each row represents a vehicle, each column a task.     1 if task is done by the vehicle, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitMatrix path value.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitVector, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    value::BitVector,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitVector value.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"struct StochasticVechicleSchedulingMaximizer{M}\n\nDeterministic vsp maximizer for the StochasticVehicleSchedulingBenchmark.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer-Tuple{AbstractVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"Apply the maximizer with the stored model builder.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"struct Task\n\nData structure for a task in the vehicle scheduling problem.\n\nFields\n\ntype::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.TaskType: type of the task (depot start, job, or depot end)\nstart_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: starting location of the task\nend_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: end location of the task\nstart_time::Float64: start time (in minutes) of the task\nend_time::Float64: end time (in minutes) of the task\nrandom_delay::Distributions.LogNormal{Float64}: lognormal distribution modeling the task start delay\nscenario_start_time::Vector{Float64}: size (nb_scenarios), observed delayed start times for each scenario\nscenario_end_time::Vector{Float64}: size (nb_scenarios), observed delayed end times for each scenario\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"Task(\n;\n    type,\n    start_point,\n    end_point,\n    start_time,\n    end_time,\n    nb_scenarios,\n    random_delay\n)\n\n\nConstructor for Task.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search","text":"_local_search(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    nb_it\n) -> Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, Any, Vector{Int64}, Vector}\n\n\nVery simple local search heuristic, using the neighborhood defined by move_one_random_task\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation","text":"column_generation(instance::Instance)\n\nNote: If you have Gurobi, use grb_model as model_builder instead of glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays","text":"compute_delays(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float64}\n\n\nCompute delays for instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features","text":"compute_features(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float32}\n\n\nReturns a matrix of features of size (20, nb_edges). For each edge, compute the following features (in the same order):\n\ntravel time\nvehicle_cost if edge is connected to source, else 0\n9 deciles of the slack\ncumulative probability distribution of the slack evaluated in [-100, -50, -20, -10, 0, 10, 50, 200, 500]\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!","text":"compute_perturbed_end_times!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n)\n\n\nCompute the end times of the tasks for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Graphs.AbstractGraph}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCompute slack for instance. TODO: differentiate from other method\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64\n) -> Vector{Float64}\n\n\nCompute slack for features.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns","text":"compute_solution_from_selected_columns(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    paths;\n    bin,\n    model_builder,\n    scenario_range,\n    silent\n) -> Tuple{Float64, Any, Any}\n\n\nNote: If you have Gurobi, use grb_model as model_builder instead od glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph","text":"create_VSP_graph(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nReturn the acyclic directed graph corresponding to city. Each vertex represents a task. Vertices are ordered by start time of corresponding task. There is an edge from task u to task v the (end time of u + tie distance between u and v <= start time of v).\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city-Tuple{}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city","text":"create_random_city(\n;\n    αᵥ_low,\n    αᵥ_high,\n    first_begin_time,\n    last_begin_time,\n    district_μ,\n    district_σ,\n    task_μ,\n    task_σ,\n    seed,\n    rng,\n    city_kwargs...\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nCreates a city from city_kwargs\nDepot location at city center\nRandomize tasks, and add two dummy tasks : one source task at time=0 from the depot,   and one destination task ending at time=end at depot\nRoll every scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum-Tuple{Any, Any, Any}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum","text":"delay_sum(path, slacks, delays)\n\nEvaluate the total delay along path.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance","text":"distance(\n    p₁::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point,\n    p₂::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point\n) -> Float64\n\n\nReturns euclidean distance between p₁ and p₂.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point-Tuple{Distributions.Distribution}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point","text":"draw_random_point(distrib::Distributions.Distribution; rng)\n\n\nReturns a Point with random x and y, drawn from distrib.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(path_value::BitMatrix, instance::Instance, scenario_index::Int)\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    scenario_index::Int64\n) -> Any\n\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task-Tuple{Integer, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Integer, Real, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task","text":"evaluate_task(\n    i_task::Integer,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    old_task_index::Integer,\n    old_delay::Real,\n    scenario::Int64\n) -> Any\n\n\nEvaluate the total delay of task i_task in scenario, knowing that current delay from task old_task_index is old_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one-Tuple{AbstractVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one","text":"find_first_one(A::AbstractVector) -> Int64\n\n\nReturns index of first non zero element of A.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!","text":"generate_scenarios!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City;\n    rng\n)\n\n\nDraw all delay scenarios for the city.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district","text":"get_district(point::Point, city::City)\n\nReturn indices of the city district containing point.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features","text":"get_features(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Matrix\n\n\nReturns the feature matrix associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of scenarios in city.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of scenarios in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of tasks in city.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of tasks in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time","text":"get_perturbed_travel_time(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64,\n    scenario::Int64\n) -> Float64\n\n\nCompute the achieved travel time of scenario scenario from old_task_index to new_task_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of-Tuple{Real}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of","text":"hour_of(minutes::Real) -> Int64\n\n\nReturns hour of the day corresponding to minutes amount.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Distributions.Distribution, Distributions.Distribution}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!","text":"init_districts!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    district_μ::Distributions.Distribution,\n    district_σ::Distributions.Distribution;\n    rng\n)\n\n\nInitialize the districts of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Real, Real, Real, Real, Distributions.Distribution, Distributions.Distribution}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!","text":"init_tasks!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    αᵥ_low::Real,\n    αᵥ_high::Real,\n    first_begin_time::Real,\n    last_begin_time::Real,\n    task_μ::Distributions.Distribution,\n    task_σ::Distributions.Distribution;\n    rng\n)\n\n\nDraw the tasks of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!-Tuple{BitMatrix, Graphs.AbstractGraph}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!","text":"move_one_random_task!(\n    path_value::BitMatrix,\n    graph::Graphs.AbstractGraph\n)\n\n\nSelect one random (uniform) task and move it to another random (uniform) feasible vehicle\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios","text":"nb_scenarios(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task\n) -> Int64\n\n\nReturn the number of scenarios for the given task.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    district::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_delay with delays drawn from random_delay distribution for each (scenario, hour) pair.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_start_time with delays drawn from the random_delay distribution of the given task for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay-Tuple{Real, Distributions.Distribution, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay","text":"scenario_next_delay(\n    previous_delay::Real,\n    random_delay::Distributions.Distribution,\n    rng::Random.AbstractRNG\n) -> Any\n\n\nReturn one scenario of future delay given current delay and delay distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array","text":"solution_from_JuMP_array(\n    x::AbstractArray,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCreate a Solution from a JuMP array.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths-Tuple{Any, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths","text":"solution_from_paths(\n    paths,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from routes.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP","text":"solve_deterministic_VSP(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    include_delays,\n    model_builder,\n    verbose\n) -> Tuple{Union{Float64, Vector{Float64}}, Any}\n\n\nReturn the optimal solution of the deterministic VSP problem associated to instance. The objective function is vehicle_cost * nb_vehicles + include_delays * delay_cost * sum_of_travel_times Note: If you have Gurobi, use grb_model as model_builder instead od highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array","text":"to_array(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns a BitMatrix, with value true at each index (i, j) if corresponding edge of graph is selected in the solution\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer-Tuple{AbstractVector}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer","text":"vsp_maximizer(\n    θ::AbstractVector;\n    instance,\n    model_builder,\n    silent\n)\n\n\nGiven arcs weights θ, solve the deterministic VSP problem associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{StochasticVehicleSchedulingBenchmark, Random.AbstractRNG}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    benchmark::StochasticVehicleSchedulingBenchmark,\n    rng::Random.AbstractRNG;\n    store_city,\n    compute_solutions,\n    algorithm,\n    kwargs...\n) -> DataSample{I, Matrix{Float32}, S, Nothing} where {I, S<:Union{Nothing, AbstractArray}}\n\n\nGenerate a sample for the given StochasticVehicleSchedulingBenchmark. If you want to not add label solutions in the sample, set compute_solutions=false. By default, they will be computed using column generation. Note that computing solutions can be time-consuming, especially for large instances. You can also use instead compact_mip or compact_linearized_mip as the algorithm to compute solutions. If you want to provide a custom algorithm to compute solutions, you can pass it as the algorithm keyword argument. If algorithm takes keyword arguments, you can pass them as well directly in kwargs.... If store_city=false, the coordinates and unnecessary information about instances will not be stored in the sample.\n\n\n\n\n\n","category":"method"},{"location":"api/#Warcraft","page":"API reference","title":"Warcraft","text":"","category":"section"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","text":"struct WarcraftBenchmark <: AbstractBenchmark\n\nBenchmark for the Warcraft shortest path problem. Does not have any field.\n\n\n\n\n\n","category":"type"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::WarcraftBenchmark) -> Vector\ngenerate_dataset(\n    ::WarcraftBenchmark,\n    dataset_size::Int64\n) -> Vector\n\n\nDownloads and decompresses the Warcraft dataset the first time it is called.\n\nwarning: Warning\ndataset_size is capped at 10000, i.e. the number of available samples in the dataset files.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{WarcraftBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    ::WarcraftBenchmark;\n    dijkstra\n) -> typeof(DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer)\n\n\nReturns an optimization algorithm that computes a longest path on the grid graph with given weights. Uses a shortest path algorithm on opposite weights to get the longest path.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{WarcraftBenchmark}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::WarcraftBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Any, Any, Any, Any, Flux.AdaptiveMaxPool{4, 2}, typeof(DecisionFocusedLearningBenchmarks.Utils.average_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.neg_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims)}\n\n\nCreate and return a Flux.Chain embedding for the Warcraft terrains, inspired by differentiation of blackbox combinatorial solvers.\n\nThe embedding is made as follows:\n\nThe first 5 layers of ResNet18 (convolution, batch normalization, relu, maxpooling and first resnet block).\nAn adaptive maxpooling layer to get a (12x12x64) tensor per input image.\nAn average over the third axis (of size 64) to get a (12x12x1) tensor per input image.\nThe element-wize neg_tensor function to get cell weights of proper sign to apply shortest path algorithms.\nA squeeze function to forget the two last dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{WarcraftBenchmark, DataSample}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    ::WarcraftBenchmark,\n    sample::DataSample;\n    θ_true,\n    θ_title,\n    y_title,\n    kwargs...\n) -> Any\n\n\nPlot the content of input DataSample as images. x as the initial image, θ as the weights, and y as the path.\n\nThe keyword argument θ_true is used to set the color range of the weights plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer-Tuple{AbstractMatrix}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer","text":"bellman_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Ford-Bellman dynamic programming algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot-Tuple{Array{Float32, 3}}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot","text":"convert_image_for_plot(\n    image::Array{Float32, 3}\n) -> Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}\n\n\nConvert image to the proper data format to enable plots in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.create_dataset-Tuple{String, Int64}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.create_dataset","text":"create_dataset(\n    decompressed_path::String,\n    nb_samples::Int64\n) -> Vector\n\n\nCreate the dataset corresponding to the data located at decompressed_path, possibly sub-sampling nb_samples points. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. It is a Vector of tuples, each Tuple being a dataset point.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer-Tuple{AbstractMatrix}","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer","text":"dijkstra_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Dijkstra algorithm.\n\nwarning: Warning\nOnly works on graph with positive weights, i.e. if θ only contains negative values.\n\n\n\n\n\n","category":"method"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","text":"grid_bellman_ford_warcraft(g, s, d, length_max)\n\nApply the Bellman-Ford algorithm on an GridGraph g, and return a ShortestPathTree with source s and destination d, among the paths having length smaller than length_max.\n\n\n\n\n\n","category":"function"},{"location":"api/#DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","page":"API reference","title":"DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","text":"read_dataset(\n    decompressed_path::String\n) -> Tuple{Any, Any, Any}\nread_dataset(\n    decompressed_path::String,\n    dtype::String\n) -> Tuple{Any, Any, Any}\n\n\nRead the dataset of type dtype at the decompressed_path location. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. They are returned separately, with proper axis permutation and image scaling to be consistent with Flux embeddings.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/dynamic_assortment/#Dynamic-Assortment","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The Dynamic Assortment problem is a sequential decision-making benchmark where an agent must repeatedly select which subset of items to offer to customers over time. The goal is to maximize total revenue while accounting for dynamic customer preferences that evolve based on purchase history.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Problem-Description","page":"Dynamic Assortment","title":"Problem Description","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/#Overview","page":"Dynamic Assortment","title":"Overview","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"In the dynamic assortment problem, a retailer has access to a catalog of N items and must decide which subset of exactly K items to offer to customers at each time step. Customers make purchasing decisions according to a choice model that depends on public features x:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Item prices: Fixed monetary cost of each item\nItem features: Static characteristics of each item (size d)\nHype: Dynamic popularity that increases when items are purchased recently, and decays over time if not purchased\nSaturation: Dynamic measure that slightly increases when specific items are purchased","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Both hype and saturation evolve over time based on the agent's assortment decisions and customer purchases, this providing an endogenous multistage stochastic optimization problem.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Mathematical-Formulation","page":"Dynamic Assortment","title":"Mathematical Formulation","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The dynamic assortment problem can be formulated as a finite-horizon Markov Decision Process (MDP) with the following components:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"State Space mathcalS: At time step t, the state s_t consists of:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"s_t = (p f h_t sigma_t t mathcalH_t)","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"where:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"p in mathbbR^N are the fixed item prices\nf in mathbbR^d times N are the static item features\nh_t in mathbbR^N are the current hype levels for each item\nsigma_t in mathbbR^N are the current saturation levels for each item\nt in 1 2 ldots T is the current time step\nmathcalH_t is the purchase history (last 5 purchases)","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Action Space mathcalA: The action at time t is an assortment selection:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"a_t subseteq 1 2 ldots N text such that  a_t = K","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Customer Choice Model: Given assortment a_t, customers choose according to a multinomial logit model:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"forall iin a_t mathbbP(i  a_t s_t) = fracexp(theta_i(s_t))sum_jin a_t exp(theta_j(s_t)) + 1","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"mathbbP(textno purchase  a_t s_t) = frac1sum_jin a_t exp(theta_j(s_t)) + 1","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"where theta_i(s_t) is the utility of item i at state s_t, computed by a hidden utility function:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"theta_i(s_t) = Phi(p_i h_t^(i) sigma_t^(i) f_cdoti)","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Transition Dynamics mathcalP(s_t+1  s_t a_t): After selecting assortment a_t and observing customer choice i^star sim mathbbP(cdot  a_t s_t), the state evolves as:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Hype Update: For each item i, compute a hype multiplier based on recent purchase history:\nm^(i) = 1 + sum_k=1^min(5 mathcalH_t) mathbf1_i = mathcalH_t-k cdot alpha_k\nwhere mathcalH_t-k is the k-th most recent purchase, and the factors are:\nalpha_1 = 002 quad alpha_2 = alpha_3 = alpha_4 = alpha_5 = -0005\nThen update: h_t+1^(i) = h_t^(i) times m^(i)\nSaturation Update:\nsigma_t+1^(i) = begincases\nsigma_t^(i) times 101  textif  i = i^star \nsigma_t^(i)  textotherwise\nendcases\nHistory Update: mathcalH_t+1 = textappend(mathcalH_t i^star) (keeping last 5 purchases)","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Reward Function r(s_t a_t s_t+1): The immediate reward is the revenue from the customer's purchase:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"r(s_t a_t s_t+1) = begincases\np_i^star  textif customer purchases item  i^star \n0  textif no purchase\nendcases","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Objective: Find a policy pi mathcalS to mathcalA that maximizes the expected cumulative reward:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"max_pi mathbbEleftsum_t=1^T r(s_t pi(s_t) s_t+1) right","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Terminal Condition: The episode terminates after T time steps, with no terminal reward.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Key-Components","page":"Dynamic Assortment","title":"Key Components","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/#[DynamicAssortmentBenchmark](@ref)","page":"Dynamic Assortment","title":"DynamicAssortmentBenchmark","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The main benchmark configuration with the following parameters:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"N: Number of items in the catalog (default: 20)\nd: Dimension of static feature vectors (default: 2) \nK: Assortment size constraint (default: 4)\nmax_steps: Number of time steps per episode (default: 80)\ncustomer_choice_model: linear mapping from features to utilities\nexogenous: Whether dynamics are exogenous (default: false)","category":"page"},{"location":"benchmarks/dynamic_assortment/#Instance-Generation","page":"Dynamic Assortment","title":"Instance Generation","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Each problem instance includes:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Prices: Random values in [1, 10] for each item, plus 0 for no-purchase\nFeatures: Random static features in [1, 10] for each item\nInitial State: Random starting hype and saturation values in [1, 10]","category":"page"},{"location":"benchmarks/dynamic_assortment/#Environment-Dynamics","page":"Dynamic Assortment","title":"Environment Dynamics","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The environment tracks:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Current time step\nPurchase history (last 5 purchases)\nCurrent hype and saturation for each item  \nCustomer utilities computed from current state","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"State Observation: Agents observe a normalized feature vector containing:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Current full features (prices, hype, saturation, static features)\nChange in hype/saturation from previous step\nChange in hype/saturation from initial state  \nNormalized current time step","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"All features are divided by 10 for normalization.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Benchmark-Policies","page":"Dynamic Assortment","title":"Benchmark Policies","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/#Expert-Policy","page":"Dynamic Assortment","title":"Expert Policy","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The expert policy computes the optimal assortment by brute-force enumeration:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Enumerate all possible K-subsets of the N items\nFor each subset, compute expected revenue using the choice model\nReturn the subset with highest expected revenue","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"This provides an optimal baseline but is computationally expensive.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Greedy-Policy","page":"Dynamic Assortment","title":"Greedy Policy","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"The greedy policy selects the K items with the highest prices, ignoring dynamic effects and customer preferences. This provides a simple baseline.","category":"page"},{"location":"benchmarks/dynamic_assortment/#Decision-Focused-Learning-Policy","page":"Dynamic Assortment","title":"Decision-Focused Learning Policy","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"xrightarrowtextStates_t\nfboxNeural network varphi_w\nxrightarrowtextCost vectortheta\nfboxTop K\nxrightarrowtextAssortmenta_t","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Components:","category":"page"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Neural Network varphi_w: Takes the current state s_t as input and predicts item utilities theta = (theta_1 ldots theta_N)\nOptimization Layer: Selects the top K items with highest predicted utilities to form the assortment a_t","category":"page"},{"location":"benchmarks/dynamic_assortment/#Reference","page":"Dynamic Assortment","title":"Reference","text":"","category":"section"},{"location":"benchmarks/dynamic_assortment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"Based on the paper: Structured Reinforcement Learning for Combinatorial Decision-Making","category":"page"},{"location":"benchmarks/ranking/#Ranking","page":"Ranking","title":"Ranking","text":"","category":"section"},{"location":"benchmarks/warcraft/#Warcraft","page":"Warcraft","title":"Warcraft","text":"","category":"section"},{"location":"benchmarks/warcraft/","page":"Warcraft","title":"Warcraft","text":"See the tutorial for a full demo of WarcraftBenchmark.","category":"page"},{"location":"benchmarks/vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"benchmarks/vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"StochasticVehicleSchedulingBenchmark.","category":"page"},{"location":"benchmark_interfaces/#Understanding-Benchmark-Interface","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interface","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"This guide explains how benchmarks work through common interfaces in DecisionFocusedLearningBenchmarks.jl. Understanding this interface is essential for using existing benchmarks and implementing new ones.","category":"page"},{"location":"benchmark_interfaces/#Core-Concepts","page":"Understanding Benchmark Interfaces","title":"Core Concepts","text":"","category":"section"},{"location":"benchmark_interfaces/#DataSample-Structure","page":"Understanding Benchmark Interfaces","title":"DataSample Structure","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"All benchmarks work with DataSample objects that encapsulate the data needed for decision-focused learning:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"@kwdef struct DataSample{I,F,S,C}\n    x::F = nothing       # Input features of the policy\n    θ::C = nothing       # Intermediate cost/utility parameters\n    y::S = nothing       # Output solution\n    info::I = nothing    # Additional data information (e.g., problem instance)\nend","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The DataSample provides flexibility, not all fields need to be populated depending on the benchmark type and use.","category":"page"},{"location":"benchmark_interfaces/#Benchmark-Type-Hierarchy","page":"Understanding Benchmark Interfaces","title":"Benchmark Type Hierarchy","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The package defines a hierarchy of three abstract types:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"AbstractBenchmark\n└── AbstractStochasticBenchmark{exogenous}\n    └── AbstractDynamicBenchmark{exogenous}","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"AbstractBenchmark: static, single-stage optimization problems\nAbstractStochasticBenchmark{exogenous}: stochastic, single stage optimization problems\nAbstractDynamicBenchmark{exogenous}: multi-stage sequential decision-making problems","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The {exogenous} type parameter indicates whether uncertainty distribution comes from external sources (true) or is influenced by decisions (false), which affects available methods.","category":"page"},{"location":"benchmark_interfaces/#Common-Interface-Methods","page":"Understanding Benchmark Interfaces","title":"Common Interface Methods","text":"","category":"section"},{"location":"benchmark_interfaces/#Data-Generation","page":"Understanding Benchmark Interfaces","title":"Data Generation","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Every benchmark must implement a data generation method:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Generate a single sample\ngenerate_sample(benchmark::AbstractBenchmark, rng::AbstractRNG; kwargs...) -> DataSample","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"This method should generate a single DataSample given a random number generator and optional parameters.","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"If needed, benchmarks can instead override the generate_dataset method to directly create the entire dataset:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"generate_dataset(benchmark::AbstractBenchmark, size::Int; kwargs...) -> Vector{DataSample}","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The default generate_dataset implementation calls generate_sample repeatedly, but benchmarks can override this for custom dataset generation logic.","category":"page"},{"location":"benchmark_interfaces/#DFL-Policy-Components","page":"Understanding Benchmark Interfaces","title":"DFL Policy Components","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Benchmarks provide the building blocks for decision-focused learning policies:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Create a statistical model (e.g., a neural network)\ngenerate_statistical_model(benchmark::AbstractBenchmark; kwargs...)\n\n# Create an optimization maximizer/solver\ngenerate_maximizer(benchmark::AbstractBenchmark; kwargs...)","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The statistical model typically maps from features x to cost parameters θ. The maximizer solves optimization problems given cost parameters θ (and potentially additional problem dependent keyword arguments), returning decision y.","category":"page"},{"location":"benchmark_interfaces/#Benchmark-Policies","page":"Understanding Benchmark Interfaces","title":"Benchmark Policies","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Benchmarks can provide baseline policies for comparison and evaluation:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Get baseline policies for comparison\ngenerate_policies(benchmark::AbstractBenchmark) -> Tuple{Policy}","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"This returns a tuple of Policy objects representing different benchmark-specific policies:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"struct Policy{F}\n    name::String\n    description::String  \n    policy_function::F\nend","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"A Policy is just a function with a name and description.","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Policies can be evaluated across multiple instances/environments using:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"evaluate_policy!(policy::Policy, instances; kwargs...) -> (rewards, data_samples)","category":"page"},{"location":"benchmark_interfaces/#Evaluation-Methods","page":"Understanding Benchmark Interfaces","title":"Evaluation Methods","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Optional methods for analysis and visualization:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Visualize data samples\nplot_data(benchmark::AbstractBenchmark, sample::DataSample; kwargs...)\nplot_instance(benchmark::AbstractBenchmark, instance; kwargs...)  \nplot_solution(benchmark::AbstractBenchmark, sample::DataSample, solution; kwargs...)\n\n# Compute optimality gap\ncompute_gap(benchmark::AbstractBenchmark, dataset, model, maximizer) -> Float64\n\n# Evaluate objective value\nobjective_value(benchmark::AbstractBenchmark, sample::DataSample, solution)","category":"page"},{"location":"benchmark_interfaces/#Benchmark-Specific-Interfaces","page":"Understanding Benchmark Interfaces","title":"Benchmark-Specific Interfaces","text":"","category":"section"},{"location":"benchmark_interfaces/#Static-Benchmarks","page":"Understanding Benchmark Interfaces","title":"Static Benchmarks","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Static benchmarks follow the basic interface above.","category":"page"},{"location":"benchmark_interfaces/#Stochastic-Benchmarks","page":"Understanding Benchmark Interfaces","title":"Stochastic Benchmarks","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Exogenous stochastic benchmarks add methods for scenario generation and anticipative solutions:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Generate uncertainty scenarios (for exogenous benchmarks)\ngenerate_scenario(benchmark::AbstractStochasticBenchmark{true}, instance; kwargs...)\n\n# Solve anticipative optimization problem for given scenario\ngenerate_anticipative_solution(benchmark::AbstractStochasticBenchmark{true}, \n                               instance, scenario; kwargs...)","category":"page"},{"location":"benchmark_interfaces/#Dynamic-Benchmarks","page":"Understanding Benchmark Interfaces","title":"Dynamic Benchmarks","text":"","category":"section"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"In order to model sequential decision-making, dynamic benchmarks additionally work with environments. For this, they implement methods to create environments from instances or datasets:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Create environment for sequential decision-making\ngenerate_environment(benchmark::AbstractDynamicBenchmark, instance, rng; kwargs...) -> <:AbstractEnvironment\n\n# Generate multiple environments\ngenerate_environments(benchmark::AbstractDynamicBenchmark, dataset; kwargs...) -> Vector{<:AbstractEnvironment}","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"Similarly to generate_dataset and generate_sample, one only needs to implement generate_environment, as generate_environments has a default implementation that calls it repeatedly.","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"The AbstractEnvironment interface is defined as follows:","category":"page"},{"location":"benchmark_interfaces/","page":"Understanding Benchmark Interfaces","title":"Understanding Benchmark Interfaces","text":"# Environment methods\nget_seed(env::AbstractEnvironment)  # Get current RNG seed\nreset!(env::AbstractEnvironment; reset_rng::Bool, seed=get_seed(env))  # Reset to initial state\nobserve(env::AbstractEnvironment) -> (obs, info)    # Get current observation  \nstep!(env::AbstractEnvironment, action) -> reward   # Take action, get reward\nis_terminated(env::AbstractEnvironment) -> Bool     # Check if episode ended","category":"page"},{"location":"benchmarks/argmax/#Argmax","page":"Argmax","title":"Argmax","text":"","category":"section"},{"location":"#DecisionFocusedLearningBenchmarks.jl","page":"Getting started","title":"DecisionFocusedLearningBenchmarks.jl","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"warning: Warning\nThis package is currently under active development. The API may change in future releases. Please refer to the documentation for the latest updates.","category":"page"},{"location":"#What-is-Decision-Focused-Learning?","page":"Getting started","title":"What is Decision-Focused Learning?","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Decision-focused learning (DFL) is a paradigm that integrates machine learning prediction with combinatorial optimization to make better decisions under uncertainty. Unlike traditional \"predict-then-optimize\" approaches that optimize prediction accuracy independently of downstream decision quality, DFL directly optimizes end-to-end decision performance.","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"A typical DFL algorithm involves training a parametrized policy that combines a statistical predictor with an optimization component:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"xrightarrowx boxedtextStatistical model  varphi_w xrightarrowtheta boxedtextCO algorithm  f xrightarrow y","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Where:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Instance x: input data (e.g., features, context)\nStatistical model varphi_w: machine learning predictor (e.g., neural network)\nParameters theta: predicted parameters for the optimization problem\nCO algorithm f: combinatorial optimization solver\nSolution y: final decision/solution","category":"page"},{"location":"#Package-Overview","page":"Getting started","title":"Package Overview","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"DecisionFocusedLearningBenchmarks.jl provides a comprehensive collection of benchmark problems for evaluating decision-focused learning algorithms. The package offers:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"Standardized benchmark problems spanning diverse application domains\nCommon interfaces for datasets, statistical models, and optimization components  \nReady-to-use pipelines compatible with InferOpt.jl and the whole JuliaDecisionFocusedLearning ecosystem\nEvaluation tools for comparing algorithm performance","category":"page"},{"location":"#Benchmark-Categories","page":"Getting started","title":"Benchmark Categories","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"The package organizes benchmarks into three main categories based on their problem structure:","category":"page"},{"location":"#Static-Benchmarks-(AbstractBenchmark)","page":"Getting started","title":"Static Benchmarks (AbstractBenchmark)","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Single-stage optimization problems with no randomness involved:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"ArgmaxBenchmark: argmax toy problem\nArgmax2DBenchmark: 2D argmax toy problem\nRankingBenchmark: ranking problem\nSubsetSelectionBenchmark: select optimal subset of items\nPortfolioOptimizationBenchmark: portfolio optimization problem\nFixedSizeShortestPathBenchmark: find shortest path on grid graphs with fixed size\nWarcraftBenchmark: shortest path on image maps","category":"page"},{"location":"#Stochastic-Benchmarks-(AbstractStochasticBenchmark)","page":"Getting started","title":"Stochastic Benchmarks (AbstractStochasticBenchmark)","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Single-stage problems with random noise affecting the objective:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"StochasticVehicleSchedulingBenchmark: stochastic vehicle scheduling under delay uncertainty","category":"page"},{"location":"#Dynamic-Benchmarks-(AbstractDynamicBenchmark)","page":"Getting started","title":"Dynamic Benchmarks (AbstractDynamicBenchmark)","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Multi-stage sequential decision-making problems:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"DynamicVehicleSchedulingBenchmark: multi-stage vehicle scheduling under customer uncertainty\nDynamicAssortmentBenchmark: sequential product assortment selection","category":"page"},{"location":"#Getting-Started","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"In a few lines of code, you can create benchmark instances, generate datasets, initialize learning components, and evaluate performance, using the same syntax across all benchmarks:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using DecisionFocusedLearningBenchmarks\n\n# Create a benchmark instance for the argmax problem\nbenchmark = ArgmaxBenchmark()\n\n# Generate training data\ndataset = generate_dataset(benchmark, 100)\n\n# Initialize policy components\nmodel = generate_statistical_model(benchmark)\nmaximizer = generate_maximizer(benchmark)\n\n# Training algorithm you want to use\n# ... your training code here ...\n\n# Evaluate performance\ngap = compute_gap(benchmark, dataset, model, maximizer)","category":"page"},{"location":"#Related-Packages","page":"Getting started","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"This package is part of the JuliaDecisionFocusedLearning organization, and built to be compatible with other packages in the ecosystem:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"InferOpt.jl: differentiable optimization layers and losses for decision-focused learning\nDecisionFocusedLearningAlgorithms.jl: collection of generic black-box implementations of decision-focused learning algorithms","category":"page"}]
}
