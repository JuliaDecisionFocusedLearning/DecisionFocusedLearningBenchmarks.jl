var documenterSearchIndex = {"docs":
[{"location":"api/fixed_shortest_path/#Fixed-size-shortest-path","page":"Fixed-size shortest path","title":"Fixed-size shortest path","text":"","category":"section"},{"location":"api/fixed_shortest_path/#Public","page":"Fixed-size shortest path","title":"Public","text":"","category":"section"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"struct FixedSizeShortestPathBenchmark <: AbstractBenchmark\n\nBenchmark problem for the shortest path problem. In this benchmark, all graphs are acyclic directed grids, all of the same size grid_size. Features are given at instance level (one dimensional vector of length p for each graph).\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int64}: grid graph instance\ngrid_size::Tuple{Int64, Int64}: grid size of graphs\np::Int64: size of feature vectors\ndeg::Int64: degree of formula between features and true weights\nν::Float32: multiplicative noise for true weights sampled between [1-ν, 1+ν], should be between 0 and 1\n\n\n\n\n\n","category":"type"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark-Tuple{}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"FixedSizeShortestPathBenchmark(\n;\n    grid_size,\n    p,\n    deg,\n    ν\n) -> FixedSizeShortestPathBenchmark\n\n\nConstructor for FixedSizeShortestPathBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(\n    bench::FixedSizeShortestPathBenchmark;\n    ...\n) -> Vector\ngenerate_dataset(\n    bench::FixedSizeShortestPathBenchmark,\n    dataset_size::Int64;\n    seed,\n    type\n) -> Vector\n\n\nGenerate dataset for the shortest path problem.\n\n\n\n\n\n","category":"function"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{FixedSizeShortestPathBenchmark}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::FixedSizeShortestPathBenchmark;\n    use_dijkstra\n) -> DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#8\"{DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#5#9\"{typeof(Graphs.dijkstra_shortest_paths), Vector{Int64}, Vector{Int64}, Int64, Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}}\n\n\nOutputs a function that computes the longest path on the grid graph, given edge weights θ as input.\n\nmaximizer = generate_maximizer(bench)\nmaximizer(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{FixedSizeShortestPathBenchmark}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::FixedSizeShortestPathBenchmark\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#Private","page":"Fixed-size shortest path","title":"Private","text":"","category":"section"},{"location":"api/ranking/#Ranking","page":"Ranking","title":"Ranking","text":"","category":"section"},{"location":"api/ranking/#Public","page":"Ranking","title":"Public","text":"","category":"section"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"struct RankingBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with ranking as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark-Tuple{}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"RankingBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> RankingBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for RankingBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#Private","page":"Ranking","title":"Private","text":"","category":"section"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.ranking-Tuple{AbstractVector}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.ranking","text":"ranking(θ::AbstractVector; rev, kwargs...) -> Any\n\n\nCompute the vector r such that rᵢ is the rank of θᵢ in θ.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(bench::RankingBenchmark; ...) -> Any\ngenerate_dataset(\n    bench::RankingBenchmark,\n    dataset_size::Int64;\n    seed,\n    noise_std\n) -> Any\n\n\nGenerate a dataset of labeled instances for the ranking problem.\n\n\n\n\n\n","category":"function"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{RankingBenchmark}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::RankingBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Ranking.ranking)\n\n\nReturn a ranking maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{RankingBenchmark}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::RankingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/fixed_size_shortest_path/#Shortest-paths","page":"Shortest paths","title":"Shortest paths","text":"","category":"section"},{"location":"benchmarks/fixed_size_shortest_path/","page":"Shortest paths","title":"Shortest paths","text":"FixedSizeShortestPathBenchmark is a benchmark problem that consists of finding the shortest path in a grid graph between the top left and bottom right corners. In this benchmark, the grid size is the same for all instances.","category":"page"},{"location":"api/portfolio_optimization/#Subset-selection","page":"Subset selection","title":"Subset selection","text":"","category":"section"},{"location":"api/portfolio_optimization/#Public","page":"Subset selection","title":"Public","text":"","category":"section"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"struct PortfolioOptimizationBenchmark <: AbstractBenchmark\n\nBenchmark problem for the portfolio optimization problem.\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\nd::Int64: number of assets\np::Int64: size of feature vectors\ndeg::Int64: hypermarameter for data generation\nν::Float32: another hyperparameter, should be positive\nΣ::Matrix{Float32}: covariance matrix\nγ::Float32: maximum variance of portfolio\nL::Matrix{Float32}: useful for dataset generation\nf::Vector{Float32}: useful for dataset generation\n\n\n\n\n\n","category":"type"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark-Tuple{}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"PortfolioOptimizationBenchmark(\n;\n    d,\n    p,\n    deg,\n    ν,\n    seed\n) -> PortfolioOptimizationBenchmark\n\n\nConstructor for PortfolioOptimizationBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(\n    bench::PortfolioOptimizationBenchmark;\n    ...\n) -> Vector\ngenerate_dataset(\n    bench::PortfolioOptimizationBenchmark,\n    dataset_size::Int64;\n    seed,\n    type\n) -> Vector\n\n\nGenerate a dataset of labeled instances for the portfolio optimization problem.\n\n\n\n\n\n","category":"function"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{PortfolioOptimizationBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::PortfolioOptimizationBenchmark\n) -> DecisionFocusedLearningBenchmarks.PortfolioOptimization.var\"#portfolio_maximizer#3\"{Float32, Matrix{Float32}, Int64}\n\n\nCreate a function solving the MIQP formulation of the portfolio optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{PortfolioOptimizationBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::PortfolioOptimizationBenchmark\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#Private","page":"Subset selection","title":"Private","text":"","category":"section"},{"location":"api/argmax_2d/#Argmax2D","page":"Argmax2D","title":"Argmax2D","text":"","category":"section"},{"location":"api/argmax_2d/#Public","page":"Argmax2D","title":"Public","text":"","category":"section"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"struct Argmax2DBenchmark{E, R} <: AbstractBenchmark\n\nArgmax becnhmark on a 2d polytope.\n\nFields\n\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\npolytope_vertex_range::Any: \n\n\n\n\n\n","category":"type"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark-Tuple{}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"Argmax2DBenchmark(\n;\n    nb_features,\n    seed,\n    polytope_vertex_range\n) -> Argmax2DBenchmark{E, Vector{Int64}} where E<:(Flux.Dense{typeof(identity), Matrix{Float32}})\n\n\nCustom constructor for Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#Private","page":"Argmax2D","title":"Private","text":"","category":"section"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(bench::Argmax2DBenchmark; ...) -> Vector\ngenerate_dataset(\n    bench::Argmax2DBenchmark,\n    dataset_size;\n    seed,\n    rng\n) -> Any\n\n\nGenerate a dataset for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"function"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{Argmax2DBenchmark}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    _::Argmax2DBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax2D.maximizer)\n\n\nMaximizer for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{Argmax2DBenchmark}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::Argmax2DBenchmark;\n    seed,\n    rng\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nGenerate a statistical model for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{Argmax2DBenchmark, DataSample}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    bench::Argmax2DBenchmark,\n    sample::DataSample;\n    instance,\n    θ,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the data sample for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#Warcraft","page":"Warcraft","title":"Warcraft","text":"","category":"section"},{"location":"api/warcraft/#Public","page":"Warcraft","title":"Public","text":"","category":"section"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","text":"struct WarcraftBenchmark <: AbstractBenchmark\n\nBenchmark for the Warcraft shortest path problem. Does not have any field.\n\n\n\n\n\n","category":"type"},{"location":"api/warcraft/#Private","page":"Warcraft","title":"Private","text":"","category":"section"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::WarcraftBenchmark) -> Vector\ngenerate_dataset(\n    ::WarcraftBenchmark,\n    dataset_size::Int64\n) -> Vector\n\n\nDownloads and decompresses the Warcraft dataset the first time it is called.\n\nwarning: Warning\ndataset_size is capped at 10000, i.e. the number of available samples in the dataset files.\n\n\n\n\n\n","category":"function"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{WarcraftBenchmark}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    ::WarcraftBenchmark;\n    dijkstra\n) -> typeof(DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer)\n\n\nReturns an optimization algorithm that computes a longest path on the grid graph with given weights. Uses a shortest path algorithm on opposite weights to get the longest path.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{WarcraftBenchmark}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::WarcraftBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Any, Any, Any, Any, Flux.AdaptiveMaxPool{4, 2}, typeof(DecisionFocusedLearningBenchmarks.Utils.average_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.neg_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims)}\n\n\nCreate and return a Flux.Chain embedding for the Warcraft terrains, inspired by differentiation of blackbox combinatorial solvers.\n\nThe embedding is made as follows:\n\nThe first 5 layers of ResNet18 (convolution, batch normalization, relu, maxpooling and first resnet block).\nAn adaptive maxpooling layer to get a (12x12x64) tensor per input image.\nAn average over the third axis (of size 64) to get a (12x12x1) tensor per input image.\nThe element-wize neg_tensor function to get cell weights of proper sign to apply shortest path algorithms.\nA squeeze function to forget the two last dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{WarcraftBenchmark, DataSample}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    ::WarcraftBenchmark,\n    sample::DataSample;\n    θ_true,\n    θ_title,\n    y_title,\n    kwargs...\n) -> Any\n\n\nPlot the content of input DataSample as images. x as the initial image, θ as the weights, and y as the path.\n\nThe keyword argument θ_true is used to set the color range of the weights plot.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer-Tuple{AbstractMatrix}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer","text":"bellman_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Ford-Bellman dynamic programming algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot-Tuple{Array{Float32, 3}}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot","text":"convert_image_for_plot(\n    image::Array{Float32, 3}\n) -> Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}\n\n\nConvert image to the proper data format to enable plots in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.create_dataset-Tuple{String, Int64}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.create_dataset","text":"create_dataset(\n    decompressed_path::String,\n    nb_samples::Int64\n) -> Vector\n\n\nCreate the dataset corresponding to the data located at decompressed_path, possibly sub-sampling nb_samples points. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. It is a Vector of tuples, each Tuple being a dataset point.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer-Tuple{AbstractMatrix}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer","text":"dijkstra_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Dijkstra algorithm.\n\nwarning: Warning\nOnly works on graph with positive weights, i.e. if θ only contains negative values.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","text":"grid_bellman_ford_warcraft(g, s, d, length_max)\n\nApply the Bellman-Ford algorithm on an GridGraph g, and return a ShortestPathTree with source s and destination d, among the paths having length smaller than length_max.\n\n\n\n\n\n","category":"function"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","text":"read_dataset(\n    decompressed_path::String\n) -> Tuple{Any, Any, Any}\nread_dataset(\n    decompressed_path::String,\n    dtype::String\n) -> Tuple{Any, Any, Any}\n\n\nRead the dataset of type dtype at the decompressed_path location. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. They are returned separately, with proper axis permutation and image scaling to be consistent with Flux embeddings.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"api/0_interface/#Public","page":"Interface","title":"Public","text":"","category":"section"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","text":"abstract type AbstractBenchmark\n\nAbstract type interface for a benchmark problem.\n\nThe following methods are mandatory for benchmarks:\n\ngenerate_dataset\ngenerate_statistical_model\ngenerate_maximizer\n\nThe following methods are optional:\n\nplot_data\nobjective_value\ncompute_gap\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.DataSample","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.DataSample","text":"struct DataSample{I, F<:AbstractArray, S<:Union{Nothing, AbstractArray}, C<:Union{Nothing, AbstractArray}}\n\nData sample data structure.\n\nFields\n\nx::AbstractArray: features\nθ_true::Union{Nothing, AbstractArray}: target cost parameters (optional)\ny_true::Union{Nothing, AbstractArray}: target solution (optional)\ninstance::Any: instance object (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.average_tensor-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.average_tensor","text":"average_tensor(x)\n\nAverage the tensor x along its third axis.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.compute_gap","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer\n) -> Any\ncompute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer,\n    op\n) -> Any\n\n\nDefault behaviour of compute_gap for a benchmark problem where features, solutions and costs are all defined.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.compute_gap-2","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(::AbstractBenchmark, dataset::Vector{<:DataSample}, statistical_model, maximizer) -> Float64\n\nCompute the average relative optimality gap of the pipeline on the dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::AbstractBenchmark, dataset_size::Int; kwargs...) -> Vector{<:DataSample}\n\nGenerate a Vector of DataSample  of length dataset_size for given benchmark. Content of the dataset can be visualized using plot_data, when it applies.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(::AbstractBenchmark; kwargs...)\n\nGenerates a maximizer function. Returns a callable f: (θ; kwargs...) -> y, where θ is a cost array and y is a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(::AbstractBenchmark; kwargs...)\n\nInitializes and return an untrained statistical model of the CO-ML pipeline. It's usually a Flux model, that takes a feature matrix x as input, and returns a cost array θ as output.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.get_path-Tuple{AbstractVector{<:Integer}, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.get_path","text":"get_path(\n    parents::AbstractVector{<:Integer},\n    s::Integer,\n    d::Integer\n) -> Vector{T} where T<:Integer\n\n\nRetrieve a path from the parents array and start sand endd`` of path.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.grid_graph-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.grid_graph","text":"grid_graph(\n    costs::AbstractArray{R, 2};\n    acyclic\n) -> SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64}\n\n\nConvert a grid of cell costs into a weighted directed graph from SimpleWeightedGraphs.jl, where the vertices correspond to the cells and the edges are weighted by the cost of the arrival cell.\n\nIf acyclic = false, a cell has edges to each one of its 8 neighbors.\nIf acyclic = true, a cell has edges to its south, east and southeast neighbors only (ensures an acyclic graph where topological sort will work)\n\nThis can be used to model the Warcraft shortest paths problem of\n\nDifferentiation of Blackbox Combinatorial Solvers, Vlastelica et al. (2019)\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.highs_model-Tuple{}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.highs_model","text":"highs_model() -> JuMP.Model\n\n\nInitialize a HiGHS model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Tuple{AbstractBenchmark, DataSample}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample\n) -> NamedTuple{(:instance,), <:Tuple{Any}}\n\n\nFor benchmarks where there is an instance object, maximizer needs the instance object as a keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{AbstractBenchmark, DataSample{Nothing, F, S, C}}} where {F, S, C}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample{Nothing, F, S, C}\n) -> @NamedTuple{instance::Nothing}\n\n\nFor simple benchmarks where there is no instance object, maximizer does not need any keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.neg_tensor-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.neg_tensor","text":"neg_tensor(x)\n\nCompute minus softplus element-wise on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Tuple{AbstractBenchmark, AbstractArray, AbstractArray}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    _::AbstractBenchmark,\n    θ::AbstractArray,\n    y::AbstractArray\n) -> Any\n\n\nDefault behaviour of objective_value.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}, AbstractArray}} where {I, F, S, C<:AbstractArray}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S, C<:AbstractArray},\n    y::AbstractArray\n) -> Any\n\n\nCompute the objective value of given solution y.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}}} where {I, F, S<:AbstractArray, C}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S<:AbstractArray, C}\n) -> Any\n\n\nCompute the objective value of the target in the sample (needs to exist).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.path_to_matrix-Tuple{Vector{<:Integer}, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.path_to_matrix","text":"path_to_matrix(\n    path::Vector{<:Integer},\n    h::Integer,\n    w::Integer\n) -> Matrix{Int64}\n\n\nTransform path into a binary matrix of size (h, w) where each cell is 1 if the cell is part of the path, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_data","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(::AbstractBenchmark, ::DataSample; kwargs...)\n\nPlot a data sample from the dataset created by generate_dataset. Check the specific benchmark documentation of plot_data for more details on the arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.scip_model-Tuple{}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.scip_model","text":"scip_model() -> JuMP.Model\n\n\nInitialize a SCIP model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims","text":"squeeze_last_dims(x)\n\nSqueeze two last dimensions on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#Private","page":"Interface","title":"Private","text":"","category":"section"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.coord_to_index-NTuple{4, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.coord_to_index","text":"coord_to_index(\n    i::Integer,\n    j::Integer,\n    h::Integer,\n    w::Integer\n) -> Any\n\n\nGiven a pair of row-column coordinates (i, j) on a grid of size (h, w), compute the corresponding vertex index in the graph generated by grid_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.count_edges-Tuple{Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.count_edges","text":"count_edges(h::Integer, w::Integer; acyclic)\n\n\nCompute the number of edges in a grid graph of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.index_to_coord-Tuple{Integer, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.index_to_coord","text":"index_to_coord(\n    v::Integer,\n    h::Integer,\n    w::Integer\n) -> Tuple{Any, Any}\n\n\nGiven a vertex index in the graph generated by grid_graph, compute the corresponding row-column coordinates (i, j) on a grid of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem-Tuple{AbstractBenchmark}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem","text":"is_minimization_problem(_::AbstractBenchmark) -> Bool\n\n\nCheck if the benchmark is a minimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_instance","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_instance","text":"plot_instance(::AbstractBenchmark, instance; kwargs...)\n\nPlot the instance object of the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_solution","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_solution","text":"plot_solution(::AbstractBenchmark, sample::DataSample, [solution]; kwargs...)\n\nPlot solution if given, else plot the target solution in the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#StatsAPI.fit-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsAPI.fit","text":"fit(\n    transform_type,\n    dataset::AbstractVector{<:DataSample};\n    kwargs...\n) -> Distributions.Cauchy\n\n\nFit the given transform type (ZScoreTransform or UnitRangeTransform) on the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.reconstruct!-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.reconstruct!","text":"reconstruct!(t, dataset::AbstractVector{<:DataSample})\n\n\nReconstruct the features in the dataset in place.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.reconstruct-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.reconstruct","text":"reconstruct(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nReconstruct the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.transform!-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.transform!","text":"transform!(t, dataset::AbstractVector{<:DataSample})\n\n\nTransform the features in the dataset in place.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.transform-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.transform","text":"transform(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nTransform the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/portfolio_optimization/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"PortfolioOptimizationBenchmark is a Markovitz portfolio optimization problem, where asset prices are unknown, and only contextual data is available to predict these prices. The goal is to predict asset prices c and maximize the expected return of a portfolio, subject to a risk constraint using this maximization program:","category":"page"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\nmaxquad  c^top x\ntextstquad  x^top Sigma x leq gamma\n 1^top x leq 1\n x geq 0\nendaligned","category":"page"},{"location":"api/vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"api/vsp/#Public","page":"Stochastic Vehicle Scheduling","title":"Public","text":"","category":"section"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","text":"struct StochasticVehicleSchedulingBenchmark <: AbstractBenchmark\n\nData structure for a stochastic vehicle scheduling benchmark.\n\nFields\n\nnb_tasks::Int64: number of tasks in each instance\nnb_scenarios::Int64: number of scenarios in each instance\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm","text":"column_generation_algorithm(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    bounding,\n    use_convex_resources,\n    silent,\n    close_gap\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nSolve input instance using column generation.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip","text":"compact_linearized_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact MIP. Quadratic constraints are linearized using Mc Cormick linearization. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip","text":"compact_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact quadratic MIP. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\nwarning: Warning\nYou need to use a solver that supports quadratic constraints to use this method.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip","text":"deterministic_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    model_builder,\n    silent\n) -> Any\n\n\nSolves the deterministic version of the vehicle scheduling problem using a MIP model. Does not take into account the stochastic nature of the problem.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible","text":"is_feasible(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    verbose\n) -> Bool\n\n\nCheck if solution is an admissible solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search","text":"local_search(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    num_iterations\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nVery simple heuristic, using local_search     initialised with the solution of the deterministic Linear program\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance","text":"plot_instance(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    color_scheme,\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution","text":"plot_solution(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset-Tuple{StochasticVehicleSchedulingBenchmark, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(\n    benchmark::StochasticVehicleSchedulingBenchmark,\n    dataset_size::Int64;\n    compute_solutions,\n    seed,\n    rng,\n    algorithm,\n    store_city,\n    kwargs...\n) -> Any\n\n\nCreate a dataset of dataset_size instances for the given StochasticVehicleSchedulingBenchmark. If you want to not add label solutions in the dataset, set compute_solutions=false. By default, they will be computed using column generation. Note that computing solutions can be time-consuming, especially for large instances. You can also use instead compact_mip or compact_linearized_mip as the algorithm to compute solutions. If you want to provide a custom algorithm to compute solutions, you can pass it as the algorithm keyword argument. If algorithm takes keyword arguments, you can pass them as well directly in kwargs.... If store_city=false, the coordinates and unnecessary information about instances will not be stored in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{StochasticVehicleSchedulingBenchmark}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::StochasticVehicleSchedulingBenchmark;\n    model_builder\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer{typeof(DecisionFocusedLearningBenchmarks.Utils.highs_model)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{StochasticVehicleSchedulingBenchmark}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::StochasticVehicleSchedulingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#Private","page":"Stochastic Vehicle Scheduling","title":"Private","text":"","category":"section"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"struct City\n\nData structure for a city in the vehicle scheduling problem. Contains all the relevant information to build an instance of the problem.\n\nFields\n\nwidth::Int64: city width (in minutes)\nvehicle_cost::Float64: cost of a vehicle in the objective function\ndelay_cost::Float64: cost of one minute delay in the objective function\nnb_tasks::Int64: number of tasks to fulfill\ntasks::Vector{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}: tasks list (see Task), that should be ordered by start time\ndistrict_width::Int64: idth (in minutes) of each district\ndistricts::Matrix{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District}: districts matrix (see District), indices corresponding to their relative positions\nrandom_inter_area_factor::Distributions.LogNormal{Float64}: a log-normal distribution modeling delay between districts\nscenario_inter_area_factor::Matrix{Float64}: size (nb_scenarios, 24), each row correspond to one scenario, each column to one hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"City(\n;\n    nb_scenarios,\n    width,\n    vehicle_cost,\n    nb_tasks,\n    tasks,\n    district_width,\n    districts,\n    delay_cost,\n    random_inter_area_factor,\n    scenario_inter_area_factor\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nConstructor for City.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"struct District\n\nData structure for a district in the vehicle scheduling problem.\n\nFields\n\nrandom_delay::Distributions.LogNormal{Float64}: log-normal distribution modeling the district delay\nscenario_delay::Matrix{Float64}: size (nb_scenarios, 24), observed delays for each scenario and hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"District(; random_delay, nb_scenarios)\n\n\nConstructor for District. Initialize a district with a given number of scenarios, with zeros in scenario_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"struct Instance{CC, G<:Graphs.AbstractGraph, M1<:(AbstractMatrix), M2<:(AbstractMatrix), F, C}\n\nInstance of the stochastic VSP problem.\n\nFields\n\ngraph::Graphs.AbstractGraph: graph computed from city with the create_VSP_graph(city::City) method\nfeatures::Matrix: features matrix computed from city\nslacks::AbstractMatrix: slack matrix\nintrinsic_delays::AbstractMatrix: intrinsic delays scenario matrix\nvehicle_cost::Any: cost of a vehicle\ndelay_cost::Any: cost of one minute delay\ncity::Any: associated city\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"Instance(\n;\n    nb_tasks,\n    nb_scenarios,\n    rng,\n    store_city,\n    kwargs...\n)\n\n\nConstructor for Instance. Build an Instance for the stochatsic vehicle scheduling problem, with nb_tasks tasks and nb_scenarios scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","text":"struct Point\n\n2D point data structure.\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"struct Solution\n\nShould always be associated with an Instance.\n\nFields\n\nvalue::BitVector: for each graph edge of instance, 1 if selected, else 0\npath_value::BitMatrix: each row represents a vehicle, each column a task.     1 if task is done by the vehicle, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitMatrix path value.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitVector, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    value::BitVector,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitVector value.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"struct StochasticVechicleSchedulingMaximizer{M}\n\nDeterministic vsp maximizer for the StochasticVehicleSchedulingBenchmark.\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"Apply the maximizer with the stored model builder.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"struct Task\n\nData structure for a task in the vehicle scheduling problem.\n\nFields\n\ntype::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.TaskType: type of the task (depot start, job, or depot end)\nstart_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: starting location of the task\nend_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: end location of the task\nstart_time::Float64: start time (in minutes) of the task\nend_time::Float64: end time (in minutes) of the task\nrandom_delay::Distributions.LogNormal{Float64}: lognormal distribution modeling the task start delay\nscenario_start_time::Vector{Float64}: size (nb_scenarios), observed delayed start times for each scenario\nscenario_end_time::Vector{Float64}: size (nb_scenarios), observed delayed end times for each scenario\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"Task(\n;\n    type,\n    start_point,\n    end_point,\n    start_time,\n    end_time,\n    nb_scenarios,\n    random_delay\n)\n\n\nConstructor for Task.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search","text":"_local_search(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    nb_it\n) -> Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, Any, Vector{Int64}, Vector}\n\n\nVery simple local search heuristic, using the neighborhood defined by move_one_random_task\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation","text":"column_generation(instance::Instance)\n\nNote: If you have Gurobi, use grb_model as model_builder instead of glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays","text":"compute_delays(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float64}\n\n\nCompute delays for instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features","text":"compute_features(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float32}\n\n\nReturns a matrix of features of size (20, nb_edges). For each edge, compute the following features (in the same order):\n\ntravel time\nvehicle_cost if edge is connected to source, else 0\n9 deciles of the slack\ncumulative probability distribution of the slack evaluated in [-100, -50, -20, -10, 0, 10, 50, 200, 500]\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!","text":"compute_perturbed_end_times!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n)\n\n\nCompute the end times of the tasks for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCompute slack for instance. TODO: differentiate from other method\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64\n) -> Vector{Float64}\n\n\nCompute slack for features.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Any}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns","text":"compute_solution_from_selected_columns(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    paths;\n    bin,\n    model_builder,\n    scenario_range,\n    silent\n) -> Tuple{Float64, Any, Any}\n\n\nNote: If you have Gurobi, use grb_model as model_builder instead od glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph","text":"create_VSP_graph(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nReturn the acyclic directed graph corresponding to city. Each vertex represents a task. Vertices are ordered by start time of corresponding task. There is an edge from task u to task v the (end time of u + tie distance between u and v <= start time of v).\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city","text":"create_random_city(\n;\n    αᵥ_low,\n    αᵥ_high,\n    first_begin_time,\n    last_begin_time,\n    district_μ,\n    district_σ,\n    task_μ,\n    task_σ,\n    seed,\n    rng,\n    city_kwargs...\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nCreates a city from city_kwargs\nDepot location at city center\nRandomize tasks, and add two dummy tasks : one source task at time=0 from the depot,   and one destination task ending at time=end at depot\nRoll every scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum-Tuple{Any, Any, Any}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum","text":"delay_sum(path, slacks, delays)\n\nEvaluate the total delay along path.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance","text":"distance(\n    p₁::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point,\n    p₂::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point\n) -> Float64\n\n\nReturns euclidean distance between p₁ and p₂.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point-Tuple{Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point","text":"draw_random_point(distrib::Distributions.Distribution; rng)\n\n\nReturns a Point with random x and y, drawn from distrib.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(path_value::BitMatrix, instance::Instance, scenario_index::Int)\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    scenario_index::Int64\n) -> Any\n\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task-Tuple{Integer, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Integer, Real, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task","text":"evaluate_task(\n    i_task::Integer,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    old_task_index::Integer,\n    old_delay::Real,\n    scenario::Int64\n) -> Any\n\n\nEvaluate the total delay of task i_task in scenario, knowing that current delay from task old_task_index is old_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one","text":"find_first_one(A::AbstractVector) -> Int64\n\n\nReturns index of first non zero element of A.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!","text":"generate_scenarios!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City;\n    rng\n)\n\n\nDraw all delay scenarios for the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district","text":"get_district(point::Point, city::City)\n\nReturn indices of the city district containing point.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features","text":"get_features(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Matrix\n\n\nReturns the feature matrix associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of scenarios in city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of scenarios in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of tasks in city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of tasks in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time","text":"get_perturbed_travel_time(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64,\n    scenario::Int64\n) -> Float64\n\n\nCompute the achieved travel time of scenario scenario from old_task_index to new_task_index.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of-Tuple{Real}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of","text":"hour_of(minutes::Real) -> Int64\n\n\nReturns hour of the day corresponding to minutes amount.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Distributions.Distribution, Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!","text":"init_districts!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    district_μ::Distributions.Distribution,\n    district_σ::Distributions.Distribution;\n    rng\n)\n\n\nInitialize the districts of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Real, Real, Real, Real, Distributions.Distribution, Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!","text":"init_tasks!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    αᵥ_low::Real,\n    αᵥ_high::Real,\n    first_begin_time::Real,\n    last_begin_time::Real,\n    task_μ::Distributions.Distribution,\n    task_σ::Distributions.Distribution;\n    rng\n)\n\n\nDraw the tasks of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!-Tuple{BitMatrix, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!","text":"move_one_random_task!(\n    path_value::BitMatrix,\n    graph::Graphs.AbstractGraph\n)\n\n\nSelect one random (uniform) task and move it to another random (uniform) feasible vehicle\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios","text":"nb_scenarios(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task\n) -> Int64\n\n\nReturn the number of scenarios for the given task.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    district::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_delay with delays drawn from random_delay distribution for each (scenario, hour) pair.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_start_time with delays drawn from the random_delay distribution of the given task for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay-Tuple{Real, Distributions.Distribution, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay","text":"scenario_next_delay(\n    previous_delay::Real,\n    random_delay::Distributions.Distribution,\n    rng::Random.AbstractRNG\n) -> Any\n\n\nReturn one scenario of future delay given current delay and delay distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array","text":"solution_from_JuMP_array(\n    x::AbstractArray,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCreate a Solution from a JuMP array.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths-Tuple{Any, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths","text":"solution_from_paths(\n    paths,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from routes.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP","text":"solve_deterministic_VSP(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    include_delays,\n    model_builder,\n    verbose\n) -> Tuple{Union{Float64, Vector{Float64}}, Any}\n\n\nReturn the optimal solution of the deterministic VSP problem associated to instance. The objective function is vehicle_cost * nb_vehicles + include_delays * delay_cost * sum_of_travel_times Note: If you have Gurobi, use grb_model as model_builder instead od highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array","text":"to_array(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns a BitMatrix, with value true at each index (i, j) if corresponding edge of graph is selected in the solution\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer","text":"vsp_maximizer(\n    θ::AbstractVector;\n    instance,\n    model_builder,\n    silent\n)\n\n\nGiven arcs weights θ, solve the deterministic VSP problem associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/subset_selection/#Subset-Selection","page":"Subset Selection","title":"Subset Selection","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"SubsetSelectionBenchmark is the most trivial benchmark problem in this package. It is minimalistic and serves as a simple example for debugging and testing purposes.","category":"page"},{"location":"benchmarks/subset_selection/#Description","page":"Subset Selection","title":"Description","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"We have a set of n items, each item having an unknown value. We want to select a subset of k items that maximizes the sum of the values of the selected items.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"As input, instead of the items costs, we are given a feature vector, such that an unknown linear mapping between the feature vector and the value of the items exists.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"By default, this linear mapping is the identity mapping, i.e., the value of each item is equal to the value of the corresponding feature vector element. However, this mapping can be changed by setting the identity_mapping parameter to false.","category":"page"},{"location":"api/subset_selection/#Subset-selection","page":"Subset selection","title":"Subset selection","text":"","category":"section"},{"location":"api/subset_selection/#Public","page":"Subset selection","title":"Public","text":"","category":"section"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","text":"struct SubsetSelectionBenchmark <: AbstractBenchmark\n\nBenchmark problem for the subset selection problem. Reference: https://arxiv.org/abs/2307.13565.\n\nThe goal is to select the best k items from a set of n items, without knowing their values, but only observing some features.\n\nFields\n\nn::Int64: total number of items\nk::Int64: number of items to select\n\n\n\n\n\n","category":"type"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(\n    bench::SubsetSelectionBenchmark;\n    ...\n) -> Any\ngenerate_dataset(\n    bench::SubsetSelectionBenchmark,\n    dataset_size::Int64;\n    seed,\n    identity_mapping\n) -> Any\n\n\nGenerate a dataset of labeled instances for the subset selection problem. The mapping between features and cost is identity.\n\n\n\n\n\n","category":"function"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{SubsetSelectionBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::SubsetSelectionBenchmark\n) -> Base.Fix2{typeof(DecisionFocusedLearningBenchmarks.SubsetSelection.top_k), Int64}\n\n\nReturn a top k maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{SubsetSelectionBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::SubsetSelectionBenchmark;\n    seed\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/subset_selection/#Private","page":"Subset selection","title":"Private","text":"","category":"section"},{"location":"warcraft/#Path-finding-on-image-maps","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In this tutorial, we showcase DecisionFocusedLearningBenchmarks.jl capabilities on one of its main benchmarks: the Warcraft benchmark. This benchmark problem is a simple path-finding problem where the goal is to find the shortest path between the top left and bottom right corners of a given image map. The map is represented as a 2D image representing a 12x12 grid, each cell having an unknown travel cost depending on the terrain type.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"First, let's load the package and create a benchmark object as follows:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using DecisionFocusedLearningBenchmarks\nb = WarcraftBenchmark()","category":"page"},{"location":"warcraft/#Dataset-generation","page":"Path-finding on image maps","title":"Dataset generation","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"These benchmark objects behave as generators that can generate various needed elements in order to build an algorithm to tackle the problem. First of all, all benchmarks are capable of generating datasets as needed, using the generate_dataset method. This method takes as input the benchmark object for which the dataset is to be generated, and a second argument specifying the number of samples to generate:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"dataset = generate_dataset(b, 50);\nnothing #hide","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We obtain a vector of DataSample objects, containing all needed data for the problem. Subdatasets can be created through regular slicing:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"train_dataset, test_dataset = dataset[1:45], dataset[46:50]","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"And getting an individual sample will return a DataSample with four fields: x, instance, θ, and y:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"sample = test_dataset[1]","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x correspond to the input features, i.e. the input image (3D array) in the Warcraft benchmark case:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x = sample.x","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ_true correspond to the true unknown terrain weights. We use the opposite of the true weights in order to formulate the optimization problem as a maximization problem:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ_true = sample.θ_true","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y_true correspond to the optimal shortest path, encoded as a binary matrix:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y_true = sample.y_true","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"instance is not used in this benchmark, therefore set to nothing:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"isnothing(sample.instance)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"For some benchmarks, we provide the following plotting method plot_data to visualize the data:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, sample)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can see here the terrain image, the true terrain weights, and the true shortest path avoiding the high cost cells.","category":"page"},{"location":"warcraft/#Building-a-pipeline","page":"Path-finding on image maps","title":"Building a pipeline","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"DecisionFocusedLearningBenchmarks also provides methods to build an hybrid machine learning and combinatorial optimization pipeline for the benchmark. First, the generate_statistical_model method generates a machine learning predictor to predict cell weights from the input image:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"model = generate_statistical_model(b)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case of the Warcraft benchmark, the model is a convolutional neural network built using the Flux.jl package.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Note that the model is not trained yet, and its parameters are randomly initialized.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Finally, the generate_maximizer method can be used to generate a combinatorial optimization algorithm that takes the predicted cell weights as input and returns the corresponding shortest path:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"maximizer = generate_maximizer(b; dijkstra=true)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case o fthe Warcraft benchmark, the method has an additional keyword argument to chose the algorithm to use: Dijkstra's algorithm or Bellman-Ford algorithm.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y = maximizer(θ)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"As we can see, currently the pipeline predicts random noise as cell weights, and therefore the maximizer returns a straight line path.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, DataSample(; x, θ_true=θ, y_true=y))","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can evaluate the current pipeline performance using the optimality gap metric:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"starting_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft/#Using-a-learning-algorithm","page":"Path-finding on image maps","title":"Using a learning algorithm","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can now train the model using the InferOpt.jl package:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using InferOpt\nusing Flux\nusing Plots\n\nperturbed_maximizer = PerturbedMultiplicative(maximizer; ε=0.2, nb_samples=100)\nloss = FenchelYoungLoss(perturbed_maximizer)\n\nstarting_gap = compute_gap(b, test_dataset, model, maximizer)\n\nopt_state = Flux.setup(Adam(1e-3), model)\nloss_history = Float64[]\nfor epoch in 1:50\n    val, grads = Flux.withgradient(model) do m\n        sum(loss(m(x), y_true) for (; x, y_true) in train_dataset) / length(train_dataset)\n    end\n    Flux.update!(opt_state, model, grads[1])\n    push!(loss_history, val)\nend\n\nplot(loss_history; xlabel=\"Epoch\", ylabel=\"Loss\", title=\"Training loss\")","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"final_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)\ny = maximizer(θ)\nplot_data(b, DataSample(; x, θ_true=θ, y_true=y))","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/warcraft/#Warcraft","page":"Warcraft","title":"Warcraft","text":"","category":"section"},{"location":"benchmarks/warcraft/","page":"Warcraft","title":"Warcraft","text":"See the tutorial for a full demo of WarcraftBenchmark.","category":"page"},{"location":"benchmarks/vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"benchmarks/vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"StochasticVehicleSchedulingBenchmark.","category":"page"},{"location":"api/argmax/#Argmax","page":"Argmax","title":"Argmax","text":"","category":"section"},{"location":"api/argmax/#Public","page":"Argmax","title":"Public","text":"","category":"section"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"struct ArgmaxBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with an argmax as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark-Tuple{}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"ArgmaxBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> ArgmaxBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for ArgmaxBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#Private","page":"Argmax","title":"Private","text":"","category":"section"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax","text":"one_hot_argmax(\n    z::AbstractArray{R<:Real, 1};\n    kwargs...\n) -> Any\n\n\nOne-hot encoding of the argmax function.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(bench::ArgmaxBenchmark; ...) -> Any\ngenerate_dataset(\n    bench::ArgmaxBenchmark,\n    dataset_size::Int64;\n    seed,\n    noise_std\n) -> Any\n\n\nGenerate a dataset of labeled instances for the argmax problem.\n\n\n\n\n\n","category":"function"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{ArgmaxBenchmark}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::ArgmaxBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax)\n\n\nReturn an argmax maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{ArgmaxBenchmark}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::ArgmaxBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"#DecisionFocusedLearningBenchmarks.jl","page":"Home","title":"DecisionFocusedLearningBenchmarks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This repository contains a collection of benchmark problems for decision-focused learning algorithms. It provides a common interface for creating datasets, associated statistical models and combinatorial optimization maximizers for building decision-focused learning pipelines. They can be used for instance as benchmarks for tools in InferOpt.jl, but can be used in any other context as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, this package provides the following benchmark problems (many more to come!):","category":"page"},{"location":"","page":"Home","title":"Home","text":"SubsetSelectionBenchmark: a minimalist subset selection problem.\nFixedSizeShortestPathBenchmark: shortest path problem with on a graph with fixed size.\nWarcraftBenchmark: shortest path problem on image maps\nPortfolioOptimizationBenchmark: portfolio optimization problem.\nStochasticVehicleSchedulingBenchmark: stochastic vehicle scheduling problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the documentation for more details.","category":"page"}]
}
