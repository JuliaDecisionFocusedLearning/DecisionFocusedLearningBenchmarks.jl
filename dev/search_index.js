var documenterSearchIndex = {"docs":
[{"location":"api/fixed_shortest_path/#Fixed-size-shortest-path","page":"Fixed-size shortest path","title":"Fixed-size shortest path","text":"","category":"section"},{"location":"api/fixed_shortest_path/#Public","page":"Fixed-size shortest path","title":"Public","text":"","category":"section"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"struct FixedSizeShortestPathBenchmark <: AbstractBenchmark\n\nBenchmark problem for the shortest path problem. In this benchmark, all graphs are acyclic directed grids, all of the same size grid_size. Features are given at instance level (one dimensional vector of length p for each graph).\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int64}: grid graph instance\ngrid_size::Tuple{Int64, Int64}: grid size of graphs\np::Int64: size of feature vectors\ndeg::Int64: degree of formula between features and true weights\nν::Float32: multiplicative noise for true weights sampled between [1-ν, 1+ν], should be between 0 and 1\n\n\n\n\n\n","category":"type"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark-Tuple{}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.FixedSizeShortestPathBenchmark","text":"FixedSizeShortestPathBenchmark(\n;\n    grid_size,\n    p,\n    deg,\n    ν\n) -> FixedSizeShortestPathBenchmark\n\n\nConstructor for FixedSizeShortestPathBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{FixedSizeShortestPathBenchmark}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::FixedSizeShortestPathBenchmark;\n    use_dijkstra\n) -> DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#8\"{DecisionFocusedLearningBenchmarks.FixedSizeShortestPath.var\"#shortest_path_maximizer#5#9\"{typeof(Graphs.dijkstra_shortest_paths), Vector{Int64}, Vector{Int64}, Int64, Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}}\n\n\nOutputs a function that computes the longest path on the grid graph, given edge weights θ as input.\n\nmaximizer = generate_maximizer(bench)\nmaximizer(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{FixedSizeShortestPathBenchmark}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::FixedSizeShortestPathBenchmark\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/fixed_shortest_path/#Private","page":"Fixed-size shortest path","title":"Private","text":"","category":"section"},{"location":"api/fixed_shortest_path/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{FixedSizeShortestPathBenchmark, Random.AbstractRNG}","page":"Fixed-size shortest path","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::FixedSizeShortestPathBenchmark,\n    rng::Random.AbstractRNG;\n    type\n) -> Union{DataSample{Nothing, Vector{Float32}, BitVector, Vector{Float32}}, DataSample{Nothing, Vector{Float32}, BitVector, Vector{Float64}}}\n\n\nGenerate a labeled sample for the fixed size shortest path benchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#Dynamic-Vehicle-Scheduling","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"","category":"section"},{"location":"api/dvsp/#Public","page":"Dynamic Vehicle Scheduling","title":"Public","text":"","category":"section"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DynamicVehicleSchedulingBenchmark","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DynamicVehicleSchedulingBenchmark","text":"struct DynamicVehicleSchedulingBenchmark <: AbstractDynamicBenchmark{true}\n\nAbstract type for dynamic vehicle scheduling benchmarks.\n\nFields\n\nmax_requests_per_epoch::Int64: maximum number of customers entering the system per epoch\nΔ_dispatch::Float64: time between decision and dispatch of a vehicle\nepoch_duration::Float64: duration of an epoch\ntwo_dimensional_features::Bool: whether to use two-dimensional features\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#Private","page":"Dynamic Vehicle Scheduling","title":"Private","text":"","category":"section"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv","text":"DVSPEnv(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance;\n    seed\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance{Float64}}, Random.MersenneTwister, Nothing}\n\n\nConstructor for DVSPEnv.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState","text":"State data structure for the Dynamic Vehicle Scheduling Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Instance","text":"struct Instance{I<:DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance, T}\n\nInstance data structure for the dynamic vehicle scheduling problem.\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.KleopatraVSPPolicy","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.KleopatraVSPPolicy","text":"struct KleopatraVSPPolicy{P}\n\nKleopatra policy for the Dynamic Vehicle Scheduling Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point","text":"struct Point{T}\n\nBasic point structure.\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance","text":"struct StaticInstance{T}\n\nInstance data structure for the (deterministic and static) Vehicle Scheduling Problem.\n\nFields\n\ncoordinate::Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T: coordinates of the locations. The first one is always the depot.\nservice_time::Vector: service time at each location\nstart_time::Vector: start time at each location\nduration::Matrix: duration matrix between locations\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","text":"struct VSPSolution\n\nSolution for the static Vehicle Scheduling Problem.\n\nFields\n\nroutes::Vector{Vector{Int64}}: list of routes, each route being a list of request indices in corresponding instance (excluding the depot).\nedge_matrix::BitMatrix: size (nblocations, nblocations). edge_matrix[i, j] is equal to 1 if a route takes edge (i, j).\n\n\n\n\n\n","category":"type"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution-Tuple{Vector{Vector{Int64}}}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution","text":"VSPSolution(\n    routes::Vector{Vector{Int64}};\n    max_index\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n\n\nBuild a VSPSolution from routes. Set max_index to manually define the size of the edge_index matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.anticipative_solver","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.anticipative_solver","text":"anticipative_solver(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv;\n    ...\n) -> Tuple{Union{Float64, Vector{Float64}}, Vector}\nanticipative_solver(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    scenario;\n    model_builder,\n    two_dimensional_features,\n    reset_env,\n    nb_epochs,\n    seed\n) -> Tuple{Union{Float64, Vector{Float64}}, Vector}\n\n\nSolve the anticipative VSP problem for environment env. For this, it uses the current environment history, so make sure that the environment is terminated before calling this method.\n\n\n\n\n\n","category":"function"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.apply_routes!-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, Vector{Vector{Int64}}}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.apply_routes!","text":"remove dispatched customers, and update must-dispatch and postponable flags.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate","text":"coordinate(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T\n\n\nGet the coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.coordinate","text":"coordinate(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Array{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.Point{T}, 1} where T\n\n\nGet the coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.cost-Tuple{Vector{Vector{Int64}}, AbstractMatrix}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.cost","text":"cost(\n    routes::Vector{Vector{Int64}},\n    duration::AbstractMatrix\n) -> Any\n\n\nCompute the total cost of a set of routes given a distance matrix, i.e. the sum of the distances between each location in the route. Note that the first location is implicitly assumed to be the depot, and should not appear in the route.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph","text":"create_graph(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nCreate the acyclic digraph associated with the given VSP state.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.create_graph","text":"create_graph(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nCreate the acyclic digraph associated with the given VSP instance.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count","text":"customer_count(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Int64\n\n\nReturn the number of customers in state.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.customer_count","text":"customer_count(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Int64\n\n\nReturn the number of customers in instance (excluding the depot).\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration","text":"duration(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Matrix\n\n\nGet the duration matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.duration","text":"duration(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Matrix\n\n\nGet the duration matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.edge_matrix-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.edge_matrix","text":"edge_matrix(\n    solution::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n) -> BitMatrix\n\n\nGet edge matrix from solution.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.is_feasible-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, Vector{Vector{Int64}}}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.is_feasible","text":"is_feasible(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState,\n    routes::Vector{Vector{Int64}};\n    verbose\n) -> Bool\n\n\nCheck if the given routes are feasible. Routes should be given with global indexation. Use env_routes_from_state_routes if needed to convert the indices beforehand.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count","text":"location_count(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Int64\n\n\nReturn the number of locations in state (customers + depot).\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.location_count","text":"location_count(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Int64\n\n\nReturn the number of locations in instance (customers + depot).\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.planning_start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.planning_start_time","text":"planning_start_time(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Any\n\n\nGet the planning start time of the environment, i.e. the time at which vehicles routes dispatched in current epoch can depart.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_instance-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.plot_instance","text":"plot_instance(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance;\n    customer_markersize,\n    depot_markersize,\n    alpha_depot,\n    customer_color,\n    depot_color,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the given static VSP instance.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.prize_collecting_vsp-Tuple{AbstractVector}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.prize_collecting_vsp","text":"prize_collecting_vsp(\n    θ::AbstractVector;\n    instance,\n    model_builder,\n    kwargs...\n)\n\n\nSolve the Prize Collecting Vehicle Scheduling Problem defined by instance and prize vector θ.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.read_vsp_instance-Tuple{String}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.read_vsp_instance","text":"read_vsp_instance(\n    filepath::String;\n    rounded,\n    normalization\n) -> DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n\n\nCreate a VSPInstance from file filepath containing a VRPTW instance. It uses time window values to compute task times as the middle of the interval.\n\nRound all values to Int if rounded=true. Normalize all time values by the normalization parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes","text":"retrieve_routes(\n    y::AbstractArray,\n    graph::Graphs.AbstractGraph\n) -> Vector{Vector{Int64}}\n\n\nRetrieve routes solution from the given MIP solution y matrix and graph.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes_anticipative-Tuple{AbstractArray, DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv, Any, Any}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.retrieve_routes_anticipative","text":"retrieve_routes_anticipative(\n    y::AbstractArray,\n    dvspenv::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    customer_index,\n    epoch_indices\n) -> Any\n\n\nRetrieve anticipative routes solution from the given MIP solution y. Outputs a set of routes per epoch.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.routes-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.routes","text":"routes(\n    solution::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.VSPSolution\n) -> Vector{Vector{Int64}}\n\n\nGet routes from solution.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.sample_indices-Tuple{Random.AbstractRNG, Any, Any}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.sample_indices","text":"sample_indices(rng::Random.AbstractRNG, k, N) -> Any\n\n\nSample k random different indices from 2 to N+1.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time","text":"service_time(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Vector\n\n\nGet the service time vector\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.service_time","text":"service_time(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Vector\n\n\nGet the service time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time","text":"start_time(\n    state::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState\n) -> Vector\n\n\nGet the start time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.start_time","text":"start_time(\n    instance::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.StaticInstance\n) -> Vector\n\n\nGet the start time vector.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.time-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.time","text":"time(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Any\n\n\nGet the current time of the environment, i.e. the start time of the current_epoch.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.Utils.is_terminated-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.is_terminated","text":"is_terminated(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Bool\n\n\nCheck if the episode is terminated, i.e. if the current epoch is the last one.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.Utils.observe-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.observe","text":"observe(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv\n) -> Tuple{Any, DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState}\n\n\nGet the current state of the environment.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.Utils.reset!-Tuple{DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv}","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.reset!","text":"reset!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv;\n    seed,\n    reset_rng\n)\n\n\nReset the environment to its initial state. Also reset the rng to seed if reset_rng is set to true.\n\n\n\n\n\n","category":"method"},{"location":"api/dvsp/#DecisionFocusedLearningBenchmarks.Utils.step!","page":"Dynamic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.step!","text":"step!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    routes\n) -> Any\nstep!(\n    env::DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPEnv,\n    routes,\n    scenario\n) -> Any\n\n\nRemove dispatched customers, advance time, and add new requests to the environment.\n\n\n\n\n\n","category":"function"},{"location":"api/ranking/#Ranking","page":"Ranking","title":"Ranking","text":"","category":"section"},{"location":"api/ranking/#Public","page":"Ranking","title":"Public","text":"","category":"section"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"struct RankingBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with ranking as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark-Tuple{}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.RankingBenchmark","text":"RankingBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> RankingBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for RankingBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#Private","page":"Ranking","title":"Private","text":"","category":"section"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Ranking.ranking-Tuple{AbstractVector}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Ranking.ranking","text":"ranking(θ::AbstractVector; rev, kwargs...) -> Any\n\n\nCompute the vector r such that rᵢ is the rank of θᵢ in θ.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{RankingBenchmark}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::RankingBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Ranking.ranking)\n\n\nReturn a ranking maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{RankingBenchmark, Random.AbstractRNG}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::RankingBenchmark,\n    rng::Random.AbstractRNG;\n    noise_std\n) -> DataSample{Nothing, Matrix{Float32}}\n\n\nGenerate a labeled sample for the ranking problem.\n\n\n\n\n\n","category":"method"},{"location":"api/ranking/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{RankingBenchmark}","page":"Ranking","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::RankingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/dynamic_assorment/#Dynamic-Assortment","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"","category":"section"},{"location":"api/dynamic_assorment/#Public","page":"Dynamic Assortment","title":"Public","text":"","category":"section"},{"location":"api/dynamic_assorment/#DecisionFocusedLearningBenchmarks.DynamicAssortment.DynamicAssortmentBenchmark","page":"Dynamic Assortment","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.DynamicAssortmentBenchmark","text":"struct DynamicAssortmentBenchmark{exogenous, M} <: AbstractDynamicBenchmark{exogenous}\n\nBenchmark for the dynamic assortment problem.\n\nFields\n\ncustomer_choice_model::Any: customer choice model (price, hype, saturation, and features)\nN::Int64: number of items\nd::Int64: dimension of feature vectors (in addition to hype, satisfaction, and price)\nK::Int64: assortment size constraint\nmax_steps::Int64: number of steps per episode\n\n\n\n\n\n","category":"type"},{"location":"api/dynamic_assorment/#Private","page":"Dynamic Assortment","title":"Private","text":"","category":"section"},{"location":"api/dynamic_assorment/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment","page":"Dynamic Assortment","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Environment","text":"mutable struct Environment{I<:DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance, R<:Random.AbstractRNG, S<:Union{Nothing, Int64}} <: AbstractEnvironment\n\nEnvironment for the dynamic assortment problem.\n\nFields\n\ninstance::DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance: associated instance\nstep::Int64: current step\npurchase_hist::Vector{Int64}: purchase history (used to update hype feature)\nrng::Random.AbstractRNG: rng\nseed::Union{Nothing, Int64}: seed for RNG\nutility::Vector{Float64}: customer utility for each item\nfeatures::Matrix{Float64}: current full features\nd_features::Matrix{Float64}: satisfaction + hype feature change from the last step\n\n\n\n\n\n","category":"type"},{"location":"api/dynamic_assorment/#DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance","page":"Dynamic Assortment","title":"DecisionFocusedLearningBenchmarks.DynamicAssortment.Instance","text":"struct Instance{B<:DynamicAssortmentBenchmark}\n\nInstance of the dynamic assortment problem.\n\nFields\n\nconfig::DynamicAssortmentBenchmark: associated benchmark\nprices::Vector{Float64}: item prices (including no purchase action)\nfeatures::Matrix{Float64}: static features, size (d, N)\nstarting_hype_and_saturation::Matrix{Float64}: starting hype and saturation features, size (2, N)\n\n\n\n\n\n","category":"type"},{"location":"api/portfolio_optimization/#Subset-selection","page":"Subset selection","title":"Subset selection","text":"","category":"section"},{"location":"api/portfolio_optimization/#Public","page":"Subset selection","title":"Public","text":"","category":"section"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"struct PortfolioOptimizationBenchmark <: AbstractBenchmark\n\nBenchmark problem for the portfolio optimization problem.\n\nData is generated using the process described in: https://arxiv.org/abs/2307.13565.\n\nFields\n\nd::Int64: number of assets\np::Int64: size of feature vectors\ndeg::Int64: hypermarameter for data generation\nν::Float32: another hyperparameter, should be positive\nΣ::Matrix{Float32}: covariance matrix\nγ::Float32: maximum variance of portfolio\nL::Matrix{Float32}: useful for dataset generation\nf::Vector{Float32}: useful for dataset generation\n\n\n\n\n\n","category":"type"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark-Tuple{}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.PortfolioOptimization.PortfolioOptimizationBenchmark","text":"PortfolioOptimizationBenchmark(\n;\n    d,\n    p,\n    deg,\n    ν,\n    seed\n) -> PortfolioOptimizationBenchmark\n\n\nConstructor for PortfolioOptimizationBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{PortfolioOptimizationBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::PortfolioOptimizationBenchmark\n) -> DecisionFocusedLearningBenchmarks.PortfolioOptimization.var\"#portfolio_maximizer#3\"{Float32, Matrix{Float32}, Int64}\n\n\nCreate a function solving the MIQP formulation of the portfolio optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{PortfolioOptimizationBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::PortfolioOptimizationBenchmark\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/portfolio_optimization/#Private","page":"Subset selection","title":"Private","text":"","category":"section"},{"location":"api/portfolio_optimization/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{PortfolioOptimizationBenchmark, Random.AbstractRNG}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::PortfolioOptimizationBenchmark,\n    rng::Random.AbstractRNG;\n    type\n) -> DataSample{Nothing, Vector{Float32}, Vector{Float64}, Vector{Float64}}\n\n\nGenerate a labeled sample for the portfolio optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#Argmax2D","page":"Argmax2D","title":"Argmax2D","text":"","category":"section"},{"location":"api/argmax_2d/#Public","page":"Argmax2D","title":"Public","text":"","category":"section"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"struct Argmax2DBenchmark{E, R} <: AbstractBenchmark\n\nArgmax becnhmark on a 2d polytope.\n\nFields\n\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\npolytope_vertex_range::Any: \n\n\n\n\n\n","category":"type"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark-Tuple{}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Argmax2D.Argmax2DBenchmark","text":"Argmax2DBenchmark(\n;\n    nb_features,\n    seed,\n    polytope_vertex_range\n) -> Argmax2DBenchmark{E, Vector{Int64}} where E<:(Flux.Dense{typeof(identity), Matrix{Float32}})\n\n\nCustom constructor for Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#Private","page":"Argmax2D","title":"Private","text":"","category":"section"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{Argmax2DBenchmark}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    _::Argmax2DBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax2D.maximizer)\n\n\nMaximizer for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{Argmax2DBenchmark, Random.AbstractRNG}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::Argmax2DBenchmark,\n    rng::Random.AbstractRNG\n) -> DataSample{_A, Vector{Float32}} where _A\n\n\nGenerate a sample for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{Argmax2DBenchmark}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::Argmax2DBenchmark;\n    seed,\n    rng\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nGenerate a statistical model for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax_2d/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{Argmax2DBenchmark, DataSample}","page":"Argmax2D","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    bench::Argmax2DBenchmark,\n    sample::DataSample;\n    instance,\n    θ,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the data sample for the Argmax2DBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#Warcraft","page":"Warcraft","title":"Warcraft","text":"","category":"section"},{"location":"api/warcraft/#Public","page":"Warcraft","title":"Public","text":"","category":"section"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.WarcraftBenchmark","text":"struct WarcraftBenchmark <: AbstractBenchmark\n\nBenchmark for the Warcraft shortest path problem. Does not have any field.\n\n\n\n\n\n","category":"type"},{"location":"api/warcraft/#Private","page":"Warcraft","title":"Private","text":"","category":"section"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::WarcraftBenchmark) -> Vector\ngenerate_dataset(\n    ::WarcraftBenchmark,\n    dataset_size::Int64\n) -> Vector\n\n\nDownloads and decompresses the Warcraft dataset the first time it is called.\n\nwarning: Warning\ndataset_size is capped at 10000, i.e. the number of available samples in the dataset files.\n\n\n\n\n\n","category":"function"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{WarcraftBenchmark}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    ::WarcraftBenchmark;\n    dijkstra\n) -> typeof(DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer)\n\n\nReturns an optimization algorithm that computes a longest path on the grid graph with given weights. Uses a shortest path algorithm on opposite weights to get the longest path.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{WarcraftBenchmark}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::WarcraftBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Any, Any, Any, Any, Flux.AdaptiveMaxPool{4, 2}, typeof(DecisionFocusedLearningBenchmarks.Utils.average_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.neg_tensor), typeof(DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims)}\n\n\nCreate and return a Flux.Chain embedding for the Warcraft terrains, inspired by differentiation of blackbox combinatorial solvers.\n\nThe embedding is made as follows:\n\nThe first 5 layers of ResNet18 (convolution, batch normalization, relu, maxpooling and first resnet block).\nAn adaptive maxpooling layer to get a (12x12x64) tensor per input image.\nAn average over the third axis (of size 64) to get a (12x12x1) tensor per input image.\nThe element-wize neg_tensor function to get cell weights of proper sign to apply shortest path algorithms.\nA squeeze function to forget the two last dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Utils.plot_data-Tuple{WarcraftBenchmark, DataSample}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(\n    ::WarcraftBenchmark,\n    sample::DataSample;\n    θ_true,\n    θ_title,\n    y_title,\n    kwargs...\n) -> Any\n\n\nPlot the content of input DataSample as images. x as the initial image, θ as the weights, and y as the path.\n\nThe keyword argument θ_true is used to set the color range of the weights plot.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer-Tuple{AbstractMatrix}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.bellman_maximizer","text":"bellman_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Ford-Bellman dynamic programming algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot-Tuple{Array{Float32, 3}}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.convert_image_for_plot","text":"convert_image_for_plot(\n    image::Array{Float32, 3}\n) -> Matrix{ColorTypes.RGB{FixedPointNumbers.N0f8}}\n\n\nConvert image to the proper data format to enable plots in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.create_dataset-Tuple{String, Int64}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.create_dataset","text":"create_dataset(\n    decompressed_path::String,\n    nb_samples::Int64\n) -> Vector\n\n\nCreate the dataset corresponding to the data located at decompressed_path, possibly sub-sampling nb_samples points. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. It is a Vector of tuples, each Tuple being a dataset point.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer-Tuple{AbstractMatrix}","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.dijkstra_maximizer","text":"dijkstra_maximizer(\n    θ::AbstractMatrix;\n    kwargs...\n) -> Matrix{Int64}\n\n\nComputes the longest path in given grid graph weights by computing the shortest path in the graph with opposite weights. Using the Dijkstra algorithm.\n\nwarning: Warning\nOnly works on graph with positive weights, i.e. if θ only contains negative values.\n\n\n\n\n\n","category":"method"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.grid_bellman_ford_warcraft","text":"grid_bellman_ford_warcraft(g, s, d, length_max)\n\nApply the Bellman-Ford algorithm on an GridGraph g, and return a ShortestPathTree with source s and destination d, among the paths having length smaller than length_max.\n\n\n\n\n\n","category":"function"},{"location":"api/warcraft/#DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","page":"Warcraft","title":"DecisionFocusedLearningBenchmarks.Warcraft.read_dataset","text":"read_dataset(\n    decompressed_path::String\n) -> Tuple{Any, Any, Any}\nread_dataset(\n    decompressed_path::String,\n    dtype::String\n) -> Tuple{Any, Any, Any}\n\n\nRead the dataset of type dtype at the decompressed_path location. The dataset is made of images of Warcraft terrains, cell cost labels and shortest path labels. They are returned separately, with proper axis permutation and image scaling to be consistent with Flux embeddings.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/fixed_size_shortest_path/#Shortest-paths","page":"Shortest paths","title":"Shortest paths","text":"","category":"section"},{"location":"benchmarks/fixed_size_shortest_path/","page":"Shortest paths","title":"Shortest paths","text":"FixedSizeShortestPathBenchmark is a benchmark problem that consists of finding the shortest path in a grid graph between the top left and bottom right corners. In this benchmark, the grid size is the same for all instances.","category":"page"},{"location":"api/0_interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"api/0_interface/#Public","page":"Interface","title":"Public","text":"","category":"section"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractBenchmark","text":"abstract type AbstractBenchmark\n\nAbstract type interface for benchmark problems.\n\nThe following methods are mandatory for benchmarks:\n\ngenerate_dataset or generate_sample\ngenerate_statistical_model\ngenerate_maximizer\n\nThe following methods are optional:\n\nplot_data\nobjective_value\ncompute_gap\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.AbstractDynamicBenchmark","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractDynamicBenchmark","text":"abstract type AbstractDynamicBenchmark{exogenous} <: AbstractStochasticBenchmark{exogenous}\n\nAbstract type interface for dynamic benchmark problems. This type should be used for benchmarks that involve multi-stage stochastic optimization problems.\n\nIt follows the same interface as AbstractStochasticBenchmark, with the addition of the following methods: TODO\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.AbstractEnvironment","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractEnvironment","text":"abstract type AbstractEnvironment\n\nAbstract type for environments in decision-focused learning benchmarks.\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.AbstractStochasticBenchmark","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.AbstractStochasticBenchmark","text":"abstract type AbstractStochasticBenchmark{exogenous} <: AbstractBenchmark\n\nAbstract type interface for stochastic benchmark problems. This type should be used for benchmarks that involve single stage stochastic optimization problems.\n\nIt follows the same interface as AbstractBenchmark, with the addition of the following methods:\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.DataSample","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.DataSample","text":"struct DataSample{I, F<:Union{Nothing, AbstractArray}, S<:Union{Nothing, AbstractArray}, C<:Union{Nothing, AbstractArray}}\n\nData sample data structure.\n\nFields\n\nx::Union{Nothing, AbstractArray}: features\nθ_true::Union{Nothing, AbstractArray}: target cost parameters (optional)\ny_true::Union{Nothing, AbstractArray}: target solution (optional)\ninstance::Any: instance object (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.Policy","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.Policy","text":"struct Policy{P}\n\nPolicy type for decision-focused learning benchmarks.\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.Policy-Tuple","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.Policy","text":"Run the policy and get the next decision on the given environment/instance.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","text":"struct TopKMaximizer\n\nTop k maximizer.\n\n\n\n\n\n","category":"type"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer","text":"TopKMaximizer(\n    k\n) -> DecisionFocusedLearningBenchmarks.Utils.TopKMaximizer\n\n\nReturn the top k indices of θ.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.average_tensor-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.average_tensor","text":"average_tensor(x)\n\nAverage the tensor x along its third axis.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.compute_gap","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer\n) -> Any\ncompute_gap(\n    bench::AbstractBenchmark,\n    dataset::AbstractVector{<:DataSample},\n    statistical_model,\n    maximizer,\n    op\n) -> Any\n\n\nDefault behaviour of compute_gap for a benchmark problem where features, solutions and costs are all defined.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.compute_gap-2","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.compute_gap","text":"compute_gap(::AbstractBenchmark, dataset::Vector{<:DataSample}, statistical_model, maximizer) -> Float64\n\nCompute the average relative optimality gap of the pipeline on the dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    envs::Vector{<:AbstractEnvironment};\n    ...\n) -> Tuple{Vector{Float64}, Any}\nevaluate_policy!(\n    policy,\n    envs::Vector{<:AbstractEnvironment},\n    episodes::Int64;\n    kwargs...\n) -> Tuple{Vector{Float64}, Any}\n\n\nRun the policy on the environments and return the total rewards and a dataset of observations. By default, the environments are reset before running the policy.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!-Tuple{Any, AbstractEnvironment, Int64}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    env::AbstractEnvironment,\n    episodes::Int64;\n    seed,\n    kwargs...\n) -> Tuple{Any, Any}\n\n\nEvaluate the policy on the environment and return the total reward and a dataset of observations. By default, the environment is reset before running the policy.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!-Tuple{Any, AbstractEnvironment}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.evaluate_policy!","text":"evaluate_policy!(\n    policy,\n    env::AbstractEnvironment;\n    kwargs...\n) -> Tuple{Any, Union{Vector{T} where T<:(DataSample{Nothing, F, S, Nothing} where {F<:Union{Nothing, AbstractArray}, S<:Union{Nothing, AbstractArray}}), Vector{T} where T<:(DataSample{I, F, S, Nothing} where {I<:DecisionFocusedLearningBenchmarks.DynamicVehicleScheduling.DVSPState, F<:Union{Nothing, AbstractArray}, S<:Union{Nothing, AbstractArray}})}}\n\n\nRun the policy on the environment and return the total reward and a dataset of observations. By default, the environment is reset before running the policy.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_anticipative_solution","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_anticipative_solution","text":"generate_anticipative_solution(::AbstractStochasticBenchmark{true}, instance, scenario; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_dataset-Tuple{AbstractBenchmark, Int64}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_dataset","text":"generate_dataset(::AbstractBenchmark, dataset_size::Int; kwargs...) -> Vector{<:DataSample}\n\nGenerate a Vector of DataSample of length dataset_size for given benchmark. Content of the dataset can be visualized using plot_data, when it applies.\n\nBy default, it uses generate_sample to create each sample in the dataset, and passes any keyword arguments to it.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_environment","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environment","text":"generate_environment(::AbstractDynamicBenchmark, instance, rng::AbstractRNG; kwargs...)\n\nInitialize an environment for the given dynamic benchmark instance.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_environments-Tuple{AbstractDynamicBenchmark, Vector{<:DataSample}}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_environments","text":"generate_environments(\n    bench::AbstractDynamicBenchmark,\n    dataset::Vector{<:DataSample};\n    seed,\n    rng,\n    kwargs...\n) -> Vector\n\n\nGenerate a vector of environments for the given dynamic benchmark and dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(::AbstractBenchmark; kwargs...)\n\nGenerates a maximizer function. Returns a callable f: (θ; kwargs...) -> y, where θ is a cost array and y is a solution.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_policies","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_policies","text":"generate_policies(::AbstractBenchmark) -> Vector{Policy}\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_sample","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(::AbstractBenchmark, rng::AbstractRNG; kwargs...) -> DataSample\n\nGenerate a single DataSample for given benchmark. This is a low-level function that is used by generate_dataset to create a dataset of samples. It is not mandatory to implement this method, but it is recommended for benchmarks that have a well-defined way to generate individual samples. An alternative is to directly implement generate_dataset to create a dataset without generating individual samples.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_scenario","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_scenario","text":"generate_scenario(::AbstractStochasticBenchmark{true}, instance; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(::AbstractBenchmark; kwargs...)\n\nInitializes and return an untrained statistical model of the CO-ML pipeline. It's usually a Flux model, that takes a feature matrix x as input, and returns a cost array θ as output.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.get_path-Tuple{AbstractVector{<:Integer}, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.get_path","text":"get_path(\n    parents::AbstractVector{<:Integer},\n    s::Integer,\n    d::Integer\n) -> Vector{T} where T<:Integer\n\n\nRetrieve a path from the parents array and start sand endd`` of path.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.get_seed-Tuple{AbstractEnvironment}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.get_seed","text":"get_seed(_::AbstractEnvironment) -> Union{Nothing, Int64}\n\n\nSeed accessor for environments. By default, environments have no seed. Override this method to provide a seed for the environment.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.grid_graph-Union{Tuple{AbstractMatrix{R}}, Tuple{R}} where R","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.grid_graph","text":"grid_graph(\n    costs::AbstractArray{R, 2};\n    acyclic\n) -> SimpleWeightedGraphs.SimpleWeightedDiGraph{Int64}\n\n\nConvert a grid of cell costs into a weighted directed graph from SimpleWeightedGraphs.jl, where the vertices correspond to the cells and the edges are weighted by the cost of the arrival cell.\n\nIf acyclic = false, a cell has edges to each one of its 8 neighbors.\nIf acyclic = true, a cell has edges to its south, east and southeast neighbors only (ensures an acyclic graph where topological sort will work)\n\nThis can be used to model the Warcraft shortest paths problem of\n\nDifferentiation of Blackbox Combinatorial Solvers, Vlastelica et al. (2019)\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.highs_model-Tuple{}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.highs_model","text":"highs_model() -> JuMP.Model\n\n\nInitialize a HiGHS model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.is_terminated","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.is_terminated","text":"is_terminated(env::AbstractEnvironment) --> Bool\n\nCheck if the environment has reached a terminal state.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Tuple{AbstractBenchmark, DataSample}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample\n) -> NamedTuple{(:instance,), <:Tuple{Any}}\n\n\nFor benchmarks where there is an instance object, maximizer needs the instance object as a keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{AbstractBenchmark, DataSample{Nothing, F, S, C}}} where {F, S, C}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.maximizer_kwargs","text":"maximizer_kwargs(\n    _::AbstractBenchmark,\n    sample::DataSample{Nothing, F, S, C}\n) -> @NamedTuple{instance::Nothing}\n\n\nFor simple benchmarks where there is no instance object, maximizer does not need any keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.neg_tensor-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.neg_tensor","text":"neg_tensor(x)\n\nCompute minus softplus element-wise on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Tuple{AbstractBenchmark, AbstractArray, AbstractArray}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    _::AbstractBenchmark,\n    θ::AbstractArray,\n    y::AbstractArray\n) -> Any\n\n\nDefault behaviour of objective_value.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}, AbstractArray}} where {I, F, S, C<:AbstractArray}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S, C<:AbstractArray},\n    y::AbstractArray\n) -> Any\n\n\nCompute the objective value of given solution y.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.objective_value-Union{Tuple{C}, Tuple{S}, Tuple{F}, Tuple{I}, Tuple{AbstractBenchmark, DataSample{I, F, S, C}}} where {I, F, S<:AbstractArray, C}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.objective_value","text":"objective_value(\n    bench::AbstractBenchmark,\n    sample::DataSample{I, F, S<:AbstractArray, C}\n) -> Any\n\n\nCompute the objective value of the target in the sample (needs to exist).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.observe","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.observe","text":"observe(env::AbstractEnvironment) --> Tuple\n\nGet the current observation from the environment. This function should return a tuple of two elements:     1. An array of features representing the current state of the environment.     2. An internal state of the environment, which can be used for further processing (return nothing if not needed).\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.path_to_matrix-Tuple{Vector{<:Integer}, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.path_to_matrix","text":"path_to_matrix(\n    path::Vector{<:Integer},\n    h::Integer,\n    w::Integer\n) -> Matrix{Int64}\n\n\nTransform path into a binary matrix of size (h, w) where each cell is 1 if the cell is part of the path, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_data","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_data","text":"plot_data(::AbstractBenchmark, ::DataSample; kwargs...)\n\nPlot a data sample from the dataset created by generate_dataset. Check the specific benchmark documentation of plot_data for more details on the arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.reset!","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.reset!","text":"reset!(env::AbstractEnvironment; reset_rng::Bool, seed=get_seed(env)) --> Nothing\n\nReset the environment to its initial state. If reset_rng is true, the random number generator is reset to the given seed.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.scip_model-Tuple{}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.scip_model","text":"scip_model() -> JuMP.Model\n\n\nInitialize a SCIP model (with disabled logging).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims-Tuple{Any}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.squeeze_last_dims","text":"squeeze_last_dims(x)\n\nSqueeze two last dimensions on tensor x.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.step!","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.step!","text":"step!(env::AbstractEnvironment, action) --> Float64\n\nPerform a step in the environment with the given action. Returns the reward received after taking the action. This function may also update the internal state of the environment. If the environment is terminated, it should raise an error.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#Private","page":"Interface","title":"Private","text":"","category":"section"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.coord_to_index-NTuple{4, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.coord_to_index","text":"coord_to_index(\n    i::Integer,\n    j::Integer,\n    h::Integer,\n    w::Integer\n) -> Any\n\n\nGiven a pair of row-column coordinates (i, j) on a grid of size (h, w), compute the corresponding vertex index in the graph generated by grid_graph.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.count_edges-Tuple{Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.count_edges","text":"count_edges(h::Integer, w::Integer; acyclic)\n\n\nCompute the number of edges in a grid graph of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.index_to_coord-Tuple{Integer, Integer, Integer}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.index_to_coord","text":"index_to_coord(\n    v::Integer,\n    h::Integer,\n    w::Integer\n) -> Tuple{Any, Any}\n\n\nGiven a vertex index in the graph generated by grid_graph, compute the corresponding row-column coordinates (i, j) on a grid of size (h, w).\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem-Tuple{AbstractBenchmark}","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.is_minimization_problem","text":"is_minimization_problem(_::AbstractBenchmark) -> Bool\n\n\nCheck if the benchmark is a minimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_instance","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_instance","text":"plot_instance(::AbstractBenchmark, instance; kwargs...)\n\nPlot the instance object of the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#DecisionFocusedLearningBenchmarks.Utils.plot_solution","page":"Interface","title":"DecisionFocusedLearningBenchmarks.Utils.plot_solution","text":"plot_solution(::AbstractBenchmark, sample::DataSample, [solution]; kwargs...)\n\nPlot solution if given, else plot the target solution in the sample.\n\n\n\n\n\n","category":"function"},{"location":"api/0_interface/#StatsAPI.fit-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsAPI.fit","text":"fit(\n    transform_type,\n    dataset::AbstractVector{<:DataSample};\n    kwargs...\n) -> Distributions.Cauchy\n\n\nFit the given transform type (ZScoreTransform or UnitRangeTransform) on the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.reconstruct!-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.reconstruct!","text":"reconstruct!(t, dataset::AbstractVector{<:DataSample})\n\n\nReconstruct the features in the dataset in place.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.reconstruct-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.reconstruct","text":"reconstruct(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nReconstruct the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.transform!-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.transform!","text":"transform!(t, dataset::AbstractVector{<:DataSample})\n\n\nTransform the features in the dataset in place.\n\n\n\n\n\n","category":"method"},{"location":"api/0_interface/#StatsBase.transform-Tuple{Any, AbstractVector{<:DataSample}}","page":"Interface","title":"StatsBase.transform","text":"transform(t, dataset::AbstractVector{<:DataSample}) -> Any\n\n\nTransform the features in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/dvsp/#Dynamic-Vehicle-Scheduling","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"","category":"section"},{"location":"benchmarks/dvsp/","page":"Dynamic Vehicle Scheduling","title":"Dynamic Vehicle Scheduling","text":"DynamicVehicleSchedulingBenchmark.","category":"page"},{"location":"api/vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"api/vsp/#Public","page":"Stochastic Vehicle Scheduling","title":"Public","text":"","category":"section"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVehicleSchedulingBenchmark","text":"struct StochasticVehicleSchedulingBenchmark <: AbstractBenchmark\n\nData structure for a stochastic vehicle scheduling benchmark.\n\nFields\n\nnb_tasks::Int64: number of tasks in each instance\nnb_scenarios::Int64: number of scenarios in each instance\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation_algorithm","text":"column_generation_algorithm(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    bounding,\n    use_convex_resources,\n    silent,\n    close_gap\n) -> BitVector\n\n\nSolve input instance using column generation.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_linearized_mip","text":"compact_linearized_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact MIP. Quadratic constraints are linearized using Mc Cormick linearization. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compact_mip","text":"compact_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    scenario_range,\n    model_builder,\n    silent\n) -> Any\n\n\nReturns the optimal solution of the Stochastic VSP instance, by solving the associated compact quadratic MIP. Note: If you have Gurobi, use grb_model as model_builder instead of highs_model.\n\nwarning: Warning\nYou need to use a solver that supports quadratic constraints to use this method.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.deterministic_mip","text":"deterministic_mip(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    model_builder,\n    silent\n) -> Any\n\n\nSolves the deterministic version of the vehicle scheduling problem using a MIP model. Does not take into account the stochastic nature of the problem.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_solution","text":"evaluate_solution(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nCompute total weighted objective of solution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.is_feasible","text":"is_feasible(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    verbose\n) -> Bool\n\n\nCheck if solution is an admissible solution of instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.local_search","text":"local_search(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    num_iterations\n) -> BitVector\n\n\nVery simple heuristic, using local_search     initialised with the solution of the deterministic Linear program\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_instance","text":"plot_instance(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution-Tuple{StochasticVehicleSchedulingBenchmark, DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}}}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.plot_solution","text":"plot_solution(\n    ::StochasticVehicleSchedulingBenchmark,\n    sample::DataSample{<:DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}};\n    kwargs...\n) -> Plots.Plot\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{StochasticVehicleSchedulingBenchmark}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    ::StochasticVehicleSchedulingBenchmark;\n    model_builder\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer{typeof(DecisionFocusedLearningBenchmarks.Utils.highs_model)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{StochasticVehicleSchedulingBenchmark}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    ::StochasticVehicleSchedulingBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#Private","page":"Stochastic Vehicle Scheduling","title":"Private","text":"","category":"section"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"struct City\n\nData structure for a city in the vehicle scheduling problem. Contains all the relevant information to build an instance of the problem.\n\nFields\n\nwidth::Int64: city width (in minutes)\nvehicle_cost::Float64: cost of a vehicle in the objective function\ndelay_cost::Float64: cost of one minute delay in the objective function\nnb_tasks::Int64: number of tasks to fulfill\ntasks::Vector{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}: tasks list (see Task), that should be ordered by start time\ndistrict_width::Int64: idth (in minutes) of each district\ndistricts::Matrix{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District}: districts matrix (see District), indices corresponding to their relative positions\nrandom_inter_area_factor::Distributions.LogNormal{Float64}: a log-normal distribution modeling delay between districts\nscenario_inter_area_factor::Matrix{Float64}: size (nb_scenarios, 24), each row correspond to one scenario, each column to one hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City","text":"City(\n;\n    nb_scenarios,\n    width,\n    vehicle_cost,\n    nb_tasks,\n    tasks,\n    district_width,\n    districts,\n    delay_cost,\n    random_inter_area_factor,\n    scenario_inter_area_factor\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nConstructor for City.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"struct District\n\nData structure for a district in the vehicle scheduling problem.\n\nFields\n\nrandom_delay::Distributions.LogNormal{Float64}: log-normal distribution modeling the district delay\nscenario_delay::Matrix{Float64}: size (nb_scenarios, 24), observed delays for each scenario and hour of the day\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District","text":"District(; random_delay, nb_scenarios)\n\n\nConstructor for District. Initialize a district with a given number of scenarios, with zeros in scenario_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"struct Instance{CC, G<:Graphs.AbstractGraph, M1<:(AbstractMatrix), M2<:(AbstractMatrix), F, C}\n\nInstance of the stochastic VSP problem.\n\nFields\n\ngraph::Graphs.AbstractGraph: graph computed from city with the create_VSP_graph(city::City) method\nfeatures::Matrix: features matrix computed from city\nslacks::AbstractMatrix: slack matrix\nintrinsic_delays::AbstractMatrix: intrinsic delays scenario matrix\nvehicle_cost::Any: cost of a vehicle\ndelay_cost::Any: cost of one minute delay\ncity::Any: associated city\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance","text":"Instance(\n;\n    nb_tasks,\n    nb_scenarios,\n    rng,\n    store_city,\n    kwargs...\n)\n\n\nConstructor for Instance. Build an Instance for the stochatsic vehicle scheduling problem, with nb_tasks tasks and nb_scenarios scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point","text":"struct Point\n\n2D point data structure.\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"struct Solution\n\nShould always be associated with an Instance.\n\nFields\n\nvalue::BitVector: for each graph edge of instance, 1 if selected, else 0\npath_value::BitMatrix: each row represents a vehicle, each column a task.     1 if task is done by the vehicle, else 0\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    path_value::BitMatrix,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitMatrix path value.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution-Tuple{BitVector, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution","text":"Solution(\n    value::BitVector,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from a BitVector value.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"struct StochasticVechicleSchedulingMaximizer{M}\n\nDeterministic vsp maximizer for the StochasticVehicleSchedulingBenchmark.\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.StochasticVechicleSchedulingMaximizer","text":"Apply the maximizer with the stored model builder.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"struct Task\n\nData structure for a task in the vehicle scheduling problem.\n\nFields\n\ntype::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.TaskType: type of the task (depot start, job, or depot end)\nstart_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: starting location of the task\nend_point::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point: end location of the task\nstart_time::Float64: start time (in minutes) of the task\nend_time::Float64: end time (in minutes) of the task\nrandom_delay::Distributions.LogNormal{Float64}: lognormal distribution modeling the task start delay\nscenario_start_time::Vector{Float64}: size (nb_scenarios), observed delayed start times for each scenario\nscenario_end_time::Vector{Float64}: size (nb_scenarios), observed delayed end times for each scenario\n\n\n\n\n\n","category":"type"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task","text":"Task(\n;\n    type,\n    start_point,\n    end_point,\n    start_time,\n    end_time,\n    nb_scenarios,\n    random_delay\n)\n\n\nConstructor for Task.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling._local_search","text":"_local_search(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    nb_it\n) -> Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, Any, Vector{Int64}, Vector}\n\n\nVery simple local search heuristic, using the neighborhood defined by move_one_random_task\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.column_generation","text":"column_generation(instance::Instance)\n\nNote: If you have Gurobi, use grb_model as model_builder instead of glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_delays","text":"compute_delays(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float64}\n\n\nCompute delays for instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_features","text":"compute_features(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Matrix{Float32}\n\n\nReturns a matrix of features of size (20, nb_edges). For each edge, compute the following features (in the same order):\n\ntravel time\nvehicle_cost if edge is connected to source, else 0\n9 deciles of the slack\ncumulative probability distribution of the slack evaluated in [-100, -50, -20, -10, 0, 10, 50, 200, 500]\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_perturbed_end_times!","text":"compute_perturbed_end_times!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n)\n\n\nCompute the end times of the tasks for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCompute slack for instance. TODO: differentiate from other method\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_slacks","text":"compute_slacks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64\n) -> Vector{Float64}\n\n\nCompute slack for features.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Any}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.compute_solution_from_selected_columns","text":"compute_solution_from_selected_columns(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    paths;\n    bin,\n    model_builder,\n    scenario_range,\n    silent\n) -> Tuple{Float64, Any, Any}\n\n\nNote: If you have Gurobi, use grb_model as model_builder instead od glpk_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_VSP_graph","text":"create_VSP_graph(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Graphs.SimpleGraphs.SimpleDiGraph{Int64}\n\n\nReturn the acyclic directed graph corresponding to city. Each vertex represents a task. Vertices are ordered by start time of corresponding task. There is an edge from task u to task v the (end time of u + tie distance between u and v <= start time of v).\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city-Tuple{}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.create_random_city","text":"create_random_city(\n;\n    αᵥ_low,\n    αᵥ_high,\n    first_begin_time,\n    last_begin_time,\n    district_μ,\n    district_σ,\n    task_μ,\n    task_σ,\n    seed,\n    rng,\n    city_kwargs...\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n\n\nCreates a city from city_kwargs\nDepot location at city center\nRandomize tasks, and add two dummy tasks : one source task at time=0 from the depot,   and one destination task ending at time=end at depot\nRoll every scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum-Tuple{Any, Any, Any}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.delay_sum","text":"delay_sum(path, slacks, delays)\n\nEvaluate the total delay along path.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.distance","text":"distance(\n    p₁::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point,\n    p₂::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point\n) -> Float64\n\n\nReturns euclidean distance between p₁ and p₂.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point-Tuple{Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.draw_random_point","text":"draw_random_point(distrib::Distributions.Distribution; rng)\n\n\nReturns a Point with random x and y, drawn from distrib.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{BitMatrix, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(path_value::BitMatrix, instance::Instance, scenario_index::Int)\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_scenario","text":"evaluate_scenario(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    scenario_index::Int64\n) -> Any\n\n\nCompute total delay of scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task-Tuple{Integer, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance, Integer, Real, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.evaluate_task","text":"evaluate_task(\n    i_task::Integer,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance,\n    old_task_index::Integer,\n    old_delay::Real,\n    scenario::Int64\n) -> Any\n\n\nEvaluate the total delay of task i_task in scenario, knowing that current delay from task old_task_index is old_delay.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.find_first_one","text":"find_first_one(A::AbstractVector) -> Int64\n\n\nReturns index of first non zero element of A.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.generate_scenarios!","text":"generate_scenarios!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City;\n    rng\n)\n\n\nDraw all delay scenarios for the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Point, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_district","text":"get_district(point::Point, city::City)\n\nReturn indices of the city district containing point.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_features","text":"get_features(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Matrix\n\n\nReturns the feature matrix associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of scenarios in city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_scenarios","text":"get_nb_scenarios(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of scenarios in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City\n) -> Int64\n\n\nReturns the number of tasks in city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_nb_tasks","text":"get_nb_tasks(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns the number of tasks in instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Int64, Int64, Int64}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.get_perturbed_travel_time","text":"get_perturbed_travel_time(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    old_task_index::Int64,\n    new_task_index::Int64,\n    scenario::Int64\n) -> Float64\n\n\nCompute the achieved travel time of scenario scenario from old_task_index to new_task_index.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of-Tuple{Real}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.hour_of","text":"hour_of(minutes::Real) -> Int64\n\n\nReturns hour of the day corresponding to minutes amount.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Distributions.Distribution, Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_districts!","text":"init_districts!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    district_μ::Distributions.Distribution,\n    district_σ::Distributions.Distribution;\n    rng\n)\n\n\nInitialize the districts of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City, Real, Real, Real, Real, Distributions.Distribution, Distributions.Distribution}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.init_tasks!","text":"init_tasks!(\n    city::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.City,\n    αᵥ_low::Real,\n    αᵥ_high::Real,\n    first_begin_time::Real,\n    last_begin_time::Real,\n    task_μ::Distributions.Distribution,\n    task_σ::Distributions.Distribution;\n    rng\n)\n\n\nDraw the tasks of the city.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!-Tuple{BitMatrix, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.move_one_random_task!","text":"move_one_random_task!(\n    path_value::BitMatrix,\n    graph::Graphs.AbstractGraph\n)\n\n\nSelect one random (uniform) task and move it to another random (uniform) feasible vehicle\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.nb_scenarios","text":"nb_scenarios(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task\n) -> Int64\n\n\nReturn the number of scenarios for the given task.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    district::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.District,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_delay with delays drawn from random_delay distribution for each (scenario, hour) pair.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.roll","text":"roll(\n    task::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Task,\n    rng::Random.AbstractRNG\n)\n\n\nPopulate scenario_start_time with delays drawn from the random_delay distribution of the given task for each scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay-Tuple{Real, Distributions.Distribution, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.scenario_next_delay","text":"scenario_next_delay(\n    previous_delay::Real,\n    random_delay::Distributions.Distribution,\n    rng::Random.AbstractRNG\n) -> Any\n\n\nReturn one scenario of future delay given current delay and delay distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array-Tuple{AbstractArray, Graphs.AbstractGraph}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_JuMP_array","text":"solution_from_JuMP_array(\n    x::AbstractArray,\n    graph::Graphs.AbstractGraph\n) -> Any\n\n\nCreate a Solution from a JuMP array.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths-Tuple{Any, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solution_from_paths","text":"solution_from_paths(\n    paths,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution\n\n\nCreate a Solution from routes.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.solve_deterministic_VSP","text":"solve_deterministic_VSP(\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance;\n    include_delays,\n    model_builder,\n    verbose\n) -> Tuple{Union{Float64, Vector{Float64}}, Any}\n\n\nReturn the optimal solution of the deterministic VSP problem associated to instance. The objective function is vehicle_cost * nb_vehicles + include_delays * delay_cost * sum_of_travel_times Note: If you have Gurobi, use grb_model as model_builder instead od highs_model.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array-Tuple{DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution, DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.to_array","text":"to_array(\n    solution::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Solution,\n    instance::DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.Instance\n) -> Any\n\n\nReturns a BitMatrix, with value true at each index (i, j) if corresponding edge of graph is selected in the solution\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer-Tuple{AbstractVector}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.StochasticVehicleScheduling.vsp_maximizer","text":"vsp_maximizer(\n    θ::AbstractVector;\n    instance,\n    model_builder,\n    silent\n)\n\n\nGiven arcs weights θ, solve the deterministic VSP problem associated to instance.\n\n\n\n\n\n","category":"method"},{"location":"api/vsp/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{StochasticVehicleSchedulingBenchmark, Random.AbstractRNG}","page":"Stochastic Vehicle Scheduling","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    benchmark::StochasticVehicleSchedulingBenchmark,\n    rng::Random.AbstractRNG;\n    store_city,\n    compute_solutions,\n    algorithm,\n    kwargs...\n) -> DataSample{I, Matrix{Float32}, S, Nothing} where {I, S<:Union{Nothing, AbstractArray}}\n\n\nGenerate a sample for the given StochasticVehicleSchedulingBenchmark. If you want to not add label solutions in the sample, set compute_solutions=false. By default, they will be computed using column generation. Note that computing solutions can be time-consuming, especially for large instances. You can also use instead compact_mip or compact_linearized_mip as the algorithm to compute solutions. If you want to provide a custom algorithm to compute solutions, you can pass it as the algorithm keyword argument. If algorithm takes keyword arguments, you can pass them as well directly in kwargs.... If store_city=false, the coordinates and unnecessary information about instances will not be stored in the sample.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/portfolio_optimization/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"PortfolioOptimizationBenchmark is a Markovitz portfolio optimization problem, where asset prices are unknown, and only contextual data is available to predict these prices. The goal is to predict asset prices c and maximize the expected return of a portfolio, subject to a risk constraint using this maximization program:","category":"page"},{"location":"benchmarks/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\nmaxquad  c^top x\ntextstquad  x^top Sigma x leq gamma\n 1^top x leq 1\n x geq 0\nendaligned","category":"page"},{"location":"benchmarks/subset_selection/#Subset-Selection","page":"Subset Selection","title":"Subset Selection","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"SubsetSelectionBenchmark is the most trivial benchmark problem in this package. It is minimalistic and serves as a simple example for debugging and testing purposes.","category":"page"},{"location":"benchmarks/subset_selection/#Description","page":"Subset Selection","title":"Description","text":"","category":"section"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"We have a set of n items, each item having an unknown value. We want to select a subset of k items that maximizes the sum of the values of the selected items.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"As input, instead of the items costs, we are given a feature vector, such that an unknown linear mapping between the feature vector and the value of the items exists.","category":"page"},{"location":"benchmarks/subset_selection/","page":"Subset Selection","title":"Subset Selection","text":"By default, this linear mapping is the identity mapping, i.e., the value of each item is equal to the value of the corresponding feature vector element. However, this mapping can be changed by setting the identity_mapping parameter to false.","category":"page"},{"location":"api/subset_selection/#Subset-selection","page":"Subset selection","title":"Subset selection","text":"","category":"section"},{"location":"api/subset_selection/#Public","page":"Subset selection","title":"Public","text":"","category":"section"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.SubsetSelection.SubsetSelectionBenchmark","text":"struct SubsetSelectionBenchmark{M} <: AbstractBenchmark\n\nBenchmark problem for the subset selection problem. Reference: https://arxiv.org/abs/2307.13565.\n\nThe goal is to select the best k items from a set of n items, without knowing their values, but only observing some features.\n\nFields\n\nn::Int64: total number of items\nk::Int64: number of items to select\nmapping::Any: hidden unknown mapping from features to costs\n\n\n\n\n\n","category":"type"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{SubsetSelectionBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::SubsetSelectionBenchmark\n) -> Base.Fix2{typeof(DecisionFocusedLearningBenchmarks.SubsetSelection.top_k), Int64}\n\n\nReturn a top k maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{SubsetSelectionBenchmark}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::SubsetSelectionBenchmark;\n    seed\n) -> Flux.Dense{typeof(identity), Matrix{Float32}}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"api/subset_selection/#Private","page":"Subset selection","title":"Private","text":"","category":"section"},{"location":"api/subset_selection/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{SubsetSelectionBenchmark, Random.AbstractRNG}","page":"Subset selection","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::SubsetSelectionBenchmark,\n    rng::Random.AbstractRNG\n) -> DataSample{Nothing, Vector{Float32}}\n\n\nGenerate a labeled instance for the subset selection problem.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/ranking/#Ranking","page":"Ranking","title":"Ranking","text":"","category":"section"},{"location":"warcraft/#Path-finding-on-image-maps","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In this tutorial, we showcase DecisionFocusedLearningBenchmarks.jl capabilities on one of its main benchmarks: the Warcraft benchmark. This benchmark problem is a simple path-finding problem where the goal is to find the shortest path between the top left and bottom right corners of a given image map. The map is represented as a 2D image representing a 12x12 grid, each cell having an unknown travel cost depending on the terrain type.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"First, let's load the package and create a benchmark object as follows:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using DecisionFocusedLearningBenchmarks\nb = WarcraftBenchmark()","category":"page"},{"location":"warcraft/#Dataset-generation","page":"Path-finding on image maps","title":"Dataset generation","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"These benchmark objects behave as generators that can generate various needed elements in order to build an algorithm to tackle the problem. First of all, all benchmarks are capable of generating datasets as needed, using the generate_dataset method. This method takes as input the benchmark object for which the dataset is to be generated, and a second argument specifying the number of samples to generate:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"dataset = generate_dataset(b, 50);\nnothing #hide","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We obtain a vector of DataSample objects, containing all needed data for the problem. Subdatasets can be created through regular slicing:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"train_dataset, test_dataset = dataset[1:45], dataset[46:50]","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"And getting an individual sample will return a DataSample with four fields: x, instance, θ, and y:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"sample = test_dataset[1]","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x correspond to the input features, i.e. the input image (3D array) in the Warcraft benchmark case:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"x = sample.x","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ_true correspond to the true unknown terrain weights. We use the opposite of the true weights in order to formulate the optimization problem as a maximization problem:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ_true = sample.θ_true","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y_true correspond to the optimal shortest path, encoded as a binary matrix:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y_true = sample.y_true","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"instance is not used in this benchmark, therefore set to nothing:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"isnothing(sample.instance)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"For some benchmarks, we provide the following plotting method plot_data to visualize the data:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, sample)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can see here the terrain image, the true terrain weights, and the true shortest path avoiding the high cost cells.","category":"page"},{"location":"warcraft/#Building-a-pipeline","page":"Path-finding on image maps","title":"Building a pipeline","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"DecisionFocusedLearningBenchmarks also provides methods to build an hybrid machine learning and combinatorial optimization pipeline for the benchmark. First, the generate_statistical_model method generates a machine learning predictor to predict cell weights from the input image:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"model = generate_statistical_model(b)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case of the Warcraft benchmark, the model is a convolutional neural network built using the Flux.jl package.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Note that the model is not trained yet, and its parameters are randomly initialized.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"Finally, the generate_maximizer method can be used to generate a combinatorial optimization algorithm that takes the predicted cell weights as input and returns the corresponding shortest path:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"maximizer = generate_maximizer(b; dijkstra=true)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"In the case o fthe Warcraft benchmark, the method has an additional keyword argument to chose the algorithm to use: Dijkstra's algorithm or Bellman-Ford algorithm.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"y = maximizer(θ)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"As we can see, currently the pipeline predicts random noise as cell weights, and therefore the maximizer returns a straight line path.","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"plot_data(b, DataSample(; x, θ_true=θ, y_true=y))","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can evaluate the current pipeline performance using the optimality gap metric:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"starting_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft/#Using-a-learning-algorithm","page":"Path-finding on image maps","title":"Using a learning algorithm","text":"","category":"section"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"We can now train the model using the InferOpt.jl package:","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"using InferOpt\nusing Flux\nusing Plots\n\nperturbed_maximizer = PerturbedMultiplicative(maximizer; ε=0.2, nb_samples=100)\nloss = FenchelYoungLoss(perturbed_maximizer)\n\nstarting_gap = compute_gap(b, test_dataset, model, maximizer)\n\nopt_state = Flux.setup(Adam(1e-3), model)\nloss_history = Float64[]\nfor epoch in 1:50\n    val, grads = Flux.withgradient(model) do m\n        sum(loss(m(x), y_true) for (; x, y_true) in train_dataset) / length(train_dataset)\n    end\n    Flux.update!(opt_state, model, grads[1])\n    push!(loss_history, val)\nend\n\nplot(loss_history; xlabel=\"Epoch\", ylabel=\"Loss\", title=\"Training loss\")","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"final_gap = compute_gap(b, test_dataset, model, maximizer)","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"θ = model(x)\ny = maximizer(θ)\nplot_data(b, DataSample(; x, θ_true=θ, y_true=y))","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"","category":"page"},{"location":"warcraft/","page":"Path-finding on image maps","title":"Path-finding on image maps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/warcraft/#Warcraft","page":"Warcraft","title":"Warcraft","text":"","category":"section"},{"location":"benchmarks/warcraft/","page":"Warcraft","title":"Warcraft","text":"See the tutorial for a full demo of WarcraftBenchmark.","category":"page"},{"location":"benchmarks/vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"benchmarks/vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"StochasticVehicleSchedulingBenchmark.","category":"page"},{"location":"api/argmax/#Argmax","page":"Argmax","title":"Argmax","text":"","category":"section"},{"location":"api/argmax/#Public","page":"Argmax","title":"Public","text":"","category":"section"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"struct ArgmaxBenchmark{E} <: AbstractBenchmark\n\nBasic benchmark problem with an argmax as the CO algorithm.\n\nFields\n\ninstance_dim::Int64: instances dimension, total number of classes\nnb_features::Int64: number of features\nencoder::Any: true mapping between features and costs\n\n\n\n\n\n","category":"type"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark-Tuple{}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.ArgmaxBenchmark","text":"ArgmaxBenchmark(\n;\n    instance_dim,\n    nb_features,\n    seed\n) -> ArgmaxBenchmark{E} where E<:(Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)})\n\n\nCustom constructor for ArgmaxBenchmark.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#Private","page":"Argmax","title":"Private","text":"","category":"section"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax","text":"one_hot_argmax(\n    z::AbstractArray{R<:Real, 1};\n    kwargs...\n) -> Any\n\n\nOne-hot encoding of the argmax function.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_maximizer-Tuple{ArgmaxBenchmark}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_maximizer","text":"generate_maximizer(\n    bench::ArgmaxBenchmark\n) -> typeof(DecisionFocusedLearningBenchmarks.Argmax.one_hot_argmax)\n\n\nReturn an argmax maximizer.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_sample-Tuple{ArgmaxBenchmark, Random.AbstractRNG}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_sample","text":"generate_sample(\n    bench::ArgmaxBenchmark,\n    rng::Random.AbstractRNG;\n    noise_std\n) -> DataSample{Nothing, Matrix{Float32}}\n\n\nGenerate a data sample for the argmax benchmark. This function generates a random feature matrix, computes the costs using the encoder, and adds noise to the costs before computing a target solution.\n\n\n\n\n\n","category":"method"},{"location":"api/argmax/#DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model-Tuple{ArgmaxBenchmark}","page":"Argmax","title":"DecisionFocusedLearningBenchmarks.Utils.generate_statistical_model","text":"generate_statistical_model(\n    bench::ArgmaxBenchmark;\n    seed\n) -> Flux.Chain{T} where T<:Tuple{Flux.Dense{typeof(identity), Matrix{Float32}}, typeof(vec)}\n\n\nInitialize a linear model for bench using Flux.\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/dynamic_assorment/#Dynamic-Assortment","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"","category":"section"},{"location":"benchmarks/dynamic_assorment/","page":"Dynamic Assortment","title":"Dynamic Assortment","text":"DynamicAssortmentBenchmark.","category":"page"},{"location":"benchmarks/argmax/#Argmax","page":"Argmax","title":"Argmax","text":"","category":"section"},{"location":"#DecisionFocusedLearningBenchmarks.jl","page":"Home","title":"DecisionFocusedLearningBenchmarks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This repository contains a collection of benchmark problems for decision-focused learning algorithms. It provides a common interface for creating datasets, associated statistical models and combinatorial optimization maximizers for building decision-focused learning pipelines. They can be used for instance as benchmarks for tools in InferOpt.jl, but can be used in any other context as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, this package provides the following benchmark problems (many more to come!):","category":"page"},{"location":"","page":"Home","title":"Home","text":"SubsetSelectionBenchmark: a minimalist subset selection problem.\nFixedSizeShortestPathBenchmark: shortest path problem with on a graph with fixed size.\nWarcraftBenchmark: shortest path problem on image maps\nPortfolioOptimizationBenchmark: portfolio optimization problem.\nStochasticVehicleSchedulingBenchmark: stochastic vehicle scheduling problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the documentation for more details.","category":"page"}]
}
